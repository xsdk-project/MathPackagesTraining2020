<!doctype html>
<html class="no-js" lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Unstructured Meshing &amp; Discretization with MFEM</title>

    <link rel="stylesheet" type="text/css" href="http://localhost:4000/assets/css/styles_feeling_responsive.css">

  

	<script src="http://localhost:4000/assets/js/modernizr.min.js"></script>

	<script src="https://ajax.googleapis.com/ajax/libs/webfont/1.5.18/webfont.js"></script>
	<script>
		WebFont.load({
			google: {
				families: [ 'Lato:400,700,400italic:latin', 'Volkhov::latin' ]
			}
		});
	</script>

	<noscript>
		<link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic%7CVolkhov' rel='stylesheet' type='text/css'>
	</noscript>


	<!-- Search Engine Optimization -->
	<meta name="description" content="At A Glance


  
    
      Questions
      Objectives
      Key Points
    
    
      What is a finite element method?
      Understand basic finite element machinery.
      Basis functions determinethe quality of the solution.
    
    
      What is a high order method?
      Understand how polynomialorder affects simulations.
      High order methods add moreunknowns on the same meshfor more precise solutions.
    
    
      What is convergence?
      Understand how convergence andconvergence rate are calculated.
      High order methods convergefaster for smooth solutions.
    
  


Note: To begin this lesson…

  Open the Answers Form
  Get into the directory containing the MFEM convergence example:
    cd HandsOnLessons/mfem_convergence
    
  


A Widely Applicable Equation

In this lesson, we demonstrate the discretization of a simple Poisson problem using
the MFEM library and examine the finite element approximation error
under uniform refinement. An example of this equation is steady-state heat
conduction.


  
    
      
      
    
  


Governing Equation

The Poisson Equation is a partial
differential equation (PDE) that can be used to model steady-state heat conduction,
electric potentials and gravitational fields. In mathematical terms …



where u is the potential field and f is the source function. This PDE is a generalization
of the Laplace Equation.

Finite Element Basics

To solve the above continuous equation using computers we need to
discretize it by introducing a finite
(discrete) number of unknowns to compute for.
In the Finite Element Method (FEM), this is
done using the concept of basis functions.

Instead of calculating the exact analytic solution u, consider approximating it by



where  are scalar unknown coefficients and  are known basis functions.
They are typically piecewise-polynomial functions which are only non-zero on small portions of the
computational mesh.


  
    
      
    
  


With finite elements, the mesh can be totally unstructured, curved and
non-conforming.


  
    
      
    
  


To solve for the unknown coefficients, we multiply Poisson’s equation by another (test)
basis function  and integrate by parts to obtain



for every basis function . (Here we are assuming homogeneous Dirichlet boundary
conditions corresponding, for example, to zero temperature on the whole boundary.)

Since the basis functions are known, we can rewrite (3) as



where







This is a  linear system that can be solved directly or
iteratively for the unknown coefficients. Note that we are free
to choose the basis functions  as we see fit.



Convergence Study Source Code

The mfem_convergence/ directory contains the convergence.cpp source code for solving the
Poisson problem using a variety of grids and orders. You can also view the code online on
GitHub.

To define the system we need to solve, we need three things. First, we need to define our
basis functions which live on the computational mesh.

   // order is the FEM basis functions polynomial order
   FiniteElementCollection *fec = new H1_FECollection(order, dim);

   // pmesh is the parallel computational mesh
   ParFiniteElementSpace *fespace = new ParFiniteElementSpace(pmesh, fec);


This defines a collection of H1 functions (meaning they have well-defined gradient) of
a given polynomial order on a parallel computational mesh pmesh. Next, we need to define
the integrals in Equation (5)

   ParBilinearForm *a = new ParBilinearForm(fespace);
   ConstantCoefficient one(1.0);
   a-&amp;gt;AddDomainIntegrator(new DiffusionIntegrator(one));
   a-&amp;gt;Assemble();


and Equation (6)

   // f_exact is a C function defining the source
   FunctionCoefficient f(f_exact);
   ParLinearForm *b = new ParLinearForm(fespace);
   b-&amp;gt;AddDomainIntegrator(new DomainLFIntegrator(f));
   b-&amp;gt;Assemble();


This defines the matrix A and the vector b. We then solve the linear
system for our solution vector x using AMG-preconditioned PCG iteration.

   // FEM -&amp;gt; Linear System
   HypreParMatrix A;
   Vector B, X;
   a-&amp;gt;FormLinearSystem(ess_tdof_list, x, *b, A, X, B);

   // AMG preconditioner
   HypreBoomerAMG *amg = new HypreBoomerAMG(A);
   amg-&amp;gt;SetPrintLevel(0);

   // PCG Krylov solver
   HyprePCG *pcg = new HyprePCG(A);
   pcg-&amp;gt;SetTol(1e-12);
   pcg-&amp;gt;SetMaxIter(200);
   pcg-&amp;gt;SetPrintLevel(0);
   pcg-&amp;gt;SetPreconditioner(*amg);

   // Solve the system A X = B
   pcg-&amp;gt;Mult(B, X);

   // Linear System -&amp;gt; FEM
   a-&amp;gt;RecoverFEMSolution(X, *b, x);


In this lesson we know what the exact solution is, so we can measure the amount of
error in our approximate solution in two ways:





We expect the error to behave like



where  is the mesh size,  is a mesh-independent constant and 
is the convergence rate.

Given approximations at two different mesh resolutions, we can  estimate the convergence rate as
follows ( doesn’t change when we refine the mesh and compare runs):



In code, this is implemented in a refinement loop as follows:

   double l2_err = x.ComputeL2Error(u);
   double h1_err = x.ComputeH1Error(&amp;amp;u, &amp;amp;u_grad, &amp;amp;one, 1.0, 1);
   pmesh-&amp;gt;GetCharacteristics(h_min, h_max, kappa_min, kappa_max);

   l2_rate = log(l2_err/l2_err_prev) / log(h_min/h_prev);
   h1_rate = log(h1_err/h1_err_prev) / log(h_min/h_prev);




Running the Convergence Study

The convergence study has the following options.

./convergence --help

Usage: ./convergence [options] ...
Options:
   -h, --help
	Print this help message and exit.
   -m &amp;lt;string&amp;gt;, --mesh &amp;lt;string&amp;gt;, current value: star.mesh
	Mesh file to use.
   -o &amp;lt;int&amp;gt;, --order &amp;lt;int&amp;gt;, current value: 1
	Finite element order (polynomial degree).
   -sc, --static-condensation, -no-sc, --no-static-condensation, current option: --no-static-condensation
	Enable static condensation.
   -r &amp;lt;int&amp;gt;, --refinements &amp;lt;int&amp;gt;, current value: 4
	Number of total uniform refinements
   -sr &amp;lt;int&amp;gt;, --serial-refinements &amp;lt;int&amp;gt;, current value: 2
	Maximum number of serial uniform refinements
   -f &amp;lt;double&amp;gt;, --frequency &amp;lt;double&amp;gt;, current value: 1
	Set the frequency for the exact solution.


Run 1 (Low order)

In this run, we will examine the error after seven uniform refinements in both the L2 and H1 norms using
first order (linear) basis functions. We use the star.mesh 2D mesh file.

./convergence -r 7
Options used:
   --mesh star.mesh
   --order 1
   --no-static-condensation
   --refinements 7
   --serial-refinements 2
   --frequency 1
----------------------------------------------------------------------------------------
DOFs            h               L^2 error       L^2 rate        H^1 error       H^1 rate
----------------------------------------------------------------------------------------
31              0.4876          0.3252          0               2.631           0
101             0.2438          0.09293         1.807           1.387           0.9229
361             0.1219          0.02393         1.957           0.7017          0.9836
1361            0.06095         0.006027        1.989           0.3518          0.996
5281            0.03048         0.00151         1.997           0.176           0.999
20801           0.01524         0.0003776       1.999           0.08803         0.9997
82561           0.007619        9.441e-05       2               0.04402         0.9999


Note that the L2 error is converging at a rate of 2 while the H1 error is only converging at a rate of 1.

Run 2 (High order)

Now consider the same run, only we are using 3rd order (cubic) basis functions instead.

./convergence -r 7 -o 3
Options used:
   --mesh star.mesh
   --order 3
   --no-static-condensation
   --refinements 7
   --serial-refinements 2
   --frequency 1
----------------------------------------------------------------------------------------
DOFs            h               L^2 error       L^2 rate        H^1 error       H^1 rate
----------------------------------------------------------------------------------------
211             0.4876          0.004777        0               0.118           0
781             0.2438          0.0003178       3.91            0.01576         2.905
3001            0.1219          2.008e-05       3.984           0.001995        2.982
11761           0.06095         1.258e-06       3.997           0.0002501       2.996
46561           0.03048         7.864e-08       4               3.129e-05       2.999
185281          0.01524         4.915e-09       4               3.912e-06       3
739201          0.007619        3.072e-10       4               4.891e-07       3


The L2 error is now converging at a rate of 4, and the H1 error is converging at a rate of 3.
This is because the exact solution in these runs is smooth, so higher-order methods
approximate it better.

Questions


  
  
  How many unknowns do we need in runs 1 and 2 to get four digits of accuracy?

  
    
    
      
          We need only 3001 unknowns compared to 82561 unknowns for the low-order method!

      
    
  



  
  
  Which method is more efficient: low-order or high-order?

  
    
    
      
          The high-order method is more efficient.

      
    
  


Run 3 (3D example)
The previous two runs used a 2D mesh in serial, but the same code can be used to run a 3D problem in parallel.

mpiexec -n 4 ./convergence -r 4 -o 2 -m inline-hex.mesh
Options used:
   --mesh inline-hex.mesh
   --order 2
   --no-static-condensation
   --refinements 4
   --serial-refinements 2
   --frequency 1
----------------------------------------------------------------------------------------
DOFs            h               L^2 error       L^2 rate        H^1 error       H^1 rate
----------------------------------------------------------------------------------------
729             0.25            0.001386        0               0.02215         0
4913            0.125           0.0001772       2.967           0.005532        2.002
35937           0.0625          2.227e-05       2.993           0.001377        2.007
274625          0.03125         2.787e-06       2.998           0.0003441       2


Questions

Experiment with different orders in 2D and 3D.


  
  
  What convergence rate will you expect in L2 and H1 for a given basis order p?

  
    
    
      
          For a smooth exact solution, the convergence rate in energy norm (H1) is p.
    Using the so-called Nitsche Trick, one can prove that we pick an additional order in L2,
    so the convergence rate there is p+1.

      
    
  




Out-Brief

We demonstrated the ease of implementing a order- and dimension-independent finite element
code in MFEM. We discussed the basics of the finite element method as well as demonstrated
the effect of the polynomial order of the basis functions on convergence rates.

Further Reading

For more information, visit the MFEM website, http://mfem.org, including the


  Features,
  Examples,
  Publications
  Finite Elements, and
  Meshing pages.


You may also be interested in visiting the websites of the related GLVis,
CEED, and BLAST projects.



Evening Hands On

The evening hands on exercise will be dedicated on getting more experience with MFEM and on reviewing
finite element discretization methods for additional physics.

(Bonus #1) Install MFEM + GLVis On Your Laptop

  Follow the building instructions here: http://mfem.org/building/.
  You should be able to download &amp;amp; install serial version of MFEM in 5min (there are no external dependencies).
  Parallel versions of MFEM requires installing hypre and METIS (also discussed above).
  Alternatively, if you already have Spack, you can build with: spack install mfem glvis.
  GLVis requires a recent version of XQuartz on Mac laptops.


Review And Run Additional Example Codes &amp;amp; Miniapps

MFEM includes a number of well-documented example codes &amp;amp; miniapps that can be
used as tutorials, as well as simple starting points for user applications.

These examples and miniapps are available in the mfem/ subdirectory of your copy of
HandsOnLessons/mfem_convergence or as top-level sub-directories in the MFEM
source code.

The full list of examples is below. Feel free to explore any of them depending on your interests, but we
recommend starting with the ones marked with a “⭐”


  Example 1: nodal H1 FEM for the Laplace problem. ⭐
  Example 2: vector FEM for linear elasticity.
  Example 3: Nedelec H(curl) FEM for the definite Maxwell problem.
  Example 4: Raviart-Thomas H(div) FEM for the grad-div problem.
  Example 5: mixed pressure-velocity FEM for the Darcy problem.
  Example 6: non-conforming adaptive mesh refinement (AMR) for the Laplace problem.
  Example 7: Laplace problem on a surface (the unit sphere). ⭐
  Example 8: Discontinuous Petrov-Galerkin (DPG) for the Laplace problem.
  Example 9: Discontinuous Galerkin (DG) time-dependent advection. ⭐
  Example 10: time-dependent implicit nonlinear elasticity. ⭐
  Example 11: parallel Laplace eigensolver.
  Example 12: parallel linear elasticity eigensolver.
  Example 13: parallel Maxwell eigensolver.
  Example 14: Discontinuous Galerkin (DG) for the Laplace problem.
  Example 15: dynamic AMR for Laplace with prescribed time-dependent source. ⭐
  Example 16: time-dependent nonlinear heat equation.
  Example 17: Discontinuous Galerkin (DG) for linear elasticity.
  Example 18: Discontinuous Galerkin (DG) for the Euler equations.
  Example 19: incompressible nonlinear elasticity.


Most of the examples have a serial and a parallel version, illustrating the ease of transition and the minimal code changes between the two.

Many of the examples also have modifications that take advantage of optional third-party libraries such as PETSc, SUNDIALS and PUMI.

Beyond the examples, a number of miniapps are available that are more representative of the advanced usage of the library in physics/application codes. Some of the included miniapps are:


  Volta: simple electrostatics simulation code.
  Tesla: simple magnetostatics simulation code.
  Maxwell: transient electromagnetics simulation code.
  Joule: transient magnetics and Joule heating miniapp.
  Shaper: resolve material interfaces by mesh refinement. ⭐
  Mesh Explorer: visualize and manipulate meshes.
  Mesh Optimizer: optimize high-order meshes.


In addition, the sources for several external benchmark/proxy-apps build on top of MFEM are available:


  Laghos: high-order Lagrangian hydrodynamics miniapp. ⭐
  Mulard: multigroup thermal radiation diffusion mini application.


(Bonus #2) Create Your Own Simple Simulation

Modify the miniapps and example codes, either in your local copy on Cooley, or on your laptop to
create a simple simulation of your own. In both cases you should be able to edit the source code
and rebuild the binary simply with make.

For example, you can solve a steady-state heat conduction problem in 2D
and 3D using the shaper miniapp (modified for the cable shape) to define the mesh and ex1
or ex1p to solve it (modified to include separate coefficients for air and cable).

We want to see your creativity – the best simulations will enter for a chance to be
featured on MFEM’s gallery page!

Please consult the MFEM code documentation and
don’t hesitate to ask if you have any implementation questions.

To Get Credit / Points

To get points, please submit screenshots, simulation images and any additional material you have
generated via Show Your Work
using the hands-on activity name MFEM_HandsOn.">
	<meta name="google-site-verification" content="Vk0IOJ2jwG_qEoG7fuEXYqv0m2rLa8P778Fi_GrsgEQ">
	<meta name="msvalidate.01" content="0FB4C028ABCF07C908C54386ABD2D97F" >
	
	<link rel="author" href="https://plus.google.com/u/0/118311555303973066167">
	
	
	<link rel="canonical" href="http://localhost:4000/lessons/mfem_convergence/">


	<!-- Facebook Open Graph -->
	<meta property="og:title" content="Unstructured Meshing &amp; Discretization with MFEM">
	<meta property="og:description" content="At A Glance


  
    
      Questions
      Objectives
      Key Points
    
    
      What is a finite element method?
      Understand basic finite element machinery.
      Basis functions determinethe quality of the solution.
    
    
      What is a high order method?
      Understand how polynomialorder affects simulations.
      High order methods add moreunknowns on the same meshfor more precise solutions.
    
    
      What is convergence?
      Understand how convergence andconvergence rate are calculated.
      High order methods convergefaster for smooth solutions.
    
  


Note: To begin this lesson…

  Open the Answers Form
  Get into the directory containing the MFEM convergence example:
    cd HandsOnLessons/mfem_convergence
    
  


A Widely Applicable Equation

In this lesson, we demonstrate the discretization of a simple Poisson problem using
the MFEM library and examine the finite element approximation error
under uniform refinement. An example of this equation is steady-state heat
conduction.


  
    
      
      
    
  


Governing Equation

The Poisson Equation is a partial
differential equation (PDE) that can be used to model steady-state heat conduction,
electric potentials and gravitational fields. In mathematical terms …



where u is the potential field and f is the source function. This PDE is a generalization
of the Laplace Equation.

Finite Element Basics

To solve the above continuous equation using computers we need to
discretize it by introducing a finite
(discrete) number of unknowns to compute for.
In the Finite Element Method (FEM), this is
done using the concept of basis functions.

Instead of calculating the exact analytic solution u, consider approximating it by



where  are scalar unknown coefficients and  are known basis functions.
They are typically piecewise-polynomial functions which are only non-zero on small portions of the
computational mesh.


  
    
      
    
  


With finite elements, the mesh can be totally unstructured, curved and
non-conforming.


  
    
      
    
  


To solve for the unknown coefficients, we multiply Poisson’s equation by another (test)
basis function  and integrate by parts to obtain



for every basis function . (Here we are assuming homogeneous Dirichlet boundary
conditions corresponding, for example, to zero temperature on the whole boundary.)

Since the basis functions are known, we can rewrite (3) as



where







This is a  linear system that can be solved directly or
iteratively for the unknown coefficients. Note that we are free
to choose the basis functions  as we see fit.



Convergence Study Source Code

The mfem_convergence/ directory contains the convergence.cpp source code for solving the
Poisson problem using a variety of grids and orders. You can also view the code online on
GitHub.

To define the system we need to solve, we need three things. First, we need to define our
basis functions which live on the computational mesh.

   // order is the FEM basis functions polynomial order
   FiniteElementCollection *fec = new H1_FECollection(order, dim);

   // pmesh is the parallel computational mesh
   ParFiniteElementSpace *fespace = new ParFiniteElementSpace(pmesh, fec);


This defines a collection of H1 functions (meaning they have well-defined gradient) of
a given polynomial order on a parallel computational mesh pmesh. Next, we need to define
the integrals in Equation (5)

   ParBilinearForm *a = new ParBilinearForm(fespace);
   ConstantCoefficient one(1.0);
   a-&amp;gt;AddDomainIntegrator(new DiffusionIntegrator(one));
   a-&amp;gt;Assemble();


and Equation (6)

   // f_exact is a C function defining the source
   FunctionCoefficient f(f_exact);
   ParLinearForm *b = new ParLinearForm(fespace);
   b-&amp;gt;AddDomainIntegrator(new DomainLFIntegrator(f));
   b-&amp;gt;Assemble();


This defines the matrix A and the vector b. We then solve the linear
system for our solution vector x using AMG-preconditioned PCG iteration.

   // FEM -&amp;gt; Linear System
   HypreParMatrix A;
   Vector B, X;
   a-&amp;gt;FormLinearSystem(ess_tdof_list, x, *b, A, X, B);

   // AMG preconditioner
   HypreBoomerAMG *amg = new HypreBoomerAMG(A);
   amg-&amp;gt;SetPrintLevel(0);

   // PCG Krylov solver
   HyprePCG *pcg = new HyprePCG(A);
   pcg-&amp;gt;SetTol(1e-12);
   pcg-&amp;gt;SetMaxIter(200);
   pcg-&amp;gt;SetPrintLevel(0);
   pcg-&amp;gt;SetPreconditioner(*amg);

   // Solve the system A X = B
   pcg-&amp;gt;Mult(B, X);

   // Linear System -&amp;gt; FEM
   a-&amp;gt;RecoverFEMSolution(X, *b, x);


In this lesson we know what the exact solution is, so we can measure the amount of
error in our approximate solution in two ways:





We expect the error to behave like



where  is the mesh size,  is a mesh-independent constant and 
is the convergence rate.

Given approximations at two different mesh resolutions, we can  estimate the convergence rate as
follows ( doesn’t change when we refine the mesh and compare runs):



In code, this is implemented in a refinement loop as follows:

   double l2_err = x.ComputeL2Error(u);
   double h1_err = x.ComputeH1Error(&amp;amp;u, &amp;amp;u_grad, &amp;amp;one, 1.0, 1);
   pmesh-&amp;gt;GetCharacteristics(h_min, h_max, kappa_min, kappa_max);

   l2_rate = log(l2_err/l2_err_prev) / log(h_min/h_prev);
   h1_rate = log(h1_err/h1_err_prev) / log(h_min/h_prev);




Running the Convergence Study

The convergence study has the following options.

./convergence --help

Usage: ./convergence [options] ...
Options:
   -h, --help
	Print this help message and exit.
   -m &amp;lt;string&amp;gt;, --mesh &amp;lt;string&amp;gt;, current value: star.mesh
	Mesh file to use.
   -o &amp;lt;int&amp;gt;, --order &amp;lt;int&amp;gt;, current value: 1
	Finite element order (polynomial degree).
   -sc, --static-condensation, -no-sc, --no-static-condensation, current option: --no-static-condensation
	Enable static condensation.
   -r &amp;lt;int&amp;gt;, --refinements &amp;lt;int&amp;gt;, current value: 4
	Number of total uniform refinements
   -sr &amp;lt;int&amp;gt;, --serial-refinements &amp;lt;int&amp;gt;, current value: 2
	Maximum number of serial uniform refinements
   -f &amp;lt;double&amp;gt;, --frequency &amp;lt;double&amp;gt;, current value: 1
	Set the frequency for the exact solution.


Run 1 (Low order)

In this run, we will examine the error after seven uniform refinements in both the L2 and H1 norms using
first order (linear) basis functions. We use the star.mesh 2D mesh file.

./convergence -r 7
Options used:
   --mesh star.mesh
   --order 1
   --no-static-condensation
   --refinements 7
   --serial-refinements 2
   --frequency 1
----------------------------------------------------------------------------------------
DOFs            h               L^2 error       L^2 rate        H^1 error       H^1 rate
----------------------------------------------------------------------------------------
31              0.4876          0.3252          0               2.631           0
101             0.2438          0.09293         1.807           1.387           0.9229
361             0.1219          0.02393         1.957           0.7017          0.9836
1361            0.06095         0.006027        1.989           0.3518          0.996
5281            0.03048         0.00151         1.997           0.176           0.999
20801           0.01524         0.0003776       1.999           0.08803         0.9997
82561           0.007619        9.441e-05       2               0.04402         0.9999


Note that the L2 error is converging at a rate of 2 while the H1 error is only converging at a rate of 1.

Run 2 (High order)

Now consider the same run, only we are using 3rd order (cubic) basis functions instead.

./convergence -r 7 -o 3
Options used:
   --mesh star.mesh
   --order 3
   --no-static-condensation
   --refinements 7
   --serial-refinements 2
   --frequency 1
----------------------------------------------------------------------------------------
DOFs            h               L^2 error       L^2 rate        H^1 error       H^1 rate
----------------------------------------------------------------------------------------
211             0.4876          0.004777        0               0.118           0
781             0.2438          0.0003178       3.91            0.01576         2.905
3001            0.1219          2.008e-05       3.984           0.001995        2.982
11761           0.06095         1.258e-06       3.997           0.0002501       2.996
46561           0.03048         7.864e-08       4               3.129e-05       2.999
185281          0.01524         4.915e-09       4               3.912e-06       3
739201          0.007619        3.072e-10       4               4.891e-07       3


The L2 error is now converging at a rate of 4, and the H1 error is converging at a rate of 3.
This is because the exact solution in these runs is smooth, so higher-order methods
approximate it better.

Questions


  
  
  How many unknowns do we need in runs 1 and 2 to get four digits of accuracy?

  
    
    
      
          We need only 3001 unknowns compared to 82561 unknowns for the low-order method!

      
    
  



  
  
  Which method is more efficient: low-order or high-order?

  
    
    
      
          The high-order method is more efficient.

      
    
  


Run 3 (3D example)
The previous two runs used a 2D mesh in serial, but the same code can be used to run a 3D problem in parallel.

mpiexec -n 4 ./convergence -r 4 -o 2 -m inline-hex.mesh
Options used:
   --mesh inline-hex.mesh
   --order 2
   --no-static-condensation
   --refinements 4
   --serial-refinements 2
   --frequency 1
----------------------------------------------------------------------------------------
DOFs            h               L^2 error       L^2 rate        H^1 error       H^1 rate
----------------------------------------------------------------------------------------
729             0.25            0.001386        0               0.02215         0
4913            0.125           0.0001772       2.967           0.005532        2.002
35937           0.0625          2.227e-05       2.993           0.001377        2.007
274625          0.03125         2.787e-06       2.998           0.0003441       2


Questions

Experiment with different orders in 2D and 3D.


  
  
  What convergence rate will you expect in L2 and H1 for a given basis order p?

  
    
    
      
          For a smooth exact solution, the convergence rate in energy norm (H1) is p.
    Using the so-called Nitsche Trick, one can prove that we pick an additional order in L2,
    so the convergence rate there is p+1.

      
    
  




Out-Brief

We demonstrated the ease of implementing a order- and dimension-independent finite element
code in MFEM. We discussed the basics of the finite element method as well as demonstrated
the effect of the polynomial order of the basis functions on convergence rates.

Further Reading

For more information, visit the MFEM website, http://mfem.org, including the


  Features,
  Examples,
  Publications
  Finite Elements, and
  Meshing pages.


You may also be interested in visiting the websites of the related GLVis,
CEED, and BLAST projects.



Evening Hands On

The evening hands on exercise will be dedicated on getting more experience with MFEM and on reviewing
finite element discretization methods for additional physics.

(Bonus #1) Install MFEM + GLVis On Your Laptop

  Follow the building instructions here: http://mfem.org/building/.
  You should be able to download &amp;amp; install serial version of MFEM in 5min (there are no external dependencies).
  Parallel versions of MFEM requires installing hypre and METIS (also discussed above).
  Alternatively, if you already have Spack, you can build with: spack install mfem glvis.
  GLVis requires a recent version of XQuartz on Mac laptops.


Review And Run Additional Example Codes &amp;amp; Miniapps

MFEM includes a number of well-documented example codes &amp;amp; miniapps that can be
used as tutorials, as well as simple starting points for user applications.

These examples and miniapps are available in the mfem/ subdirectory of your copy of
HandsOnLessons/mfem_convergence or as top-level sub-directories in the MFEM
source code.

The full list of examples is below. Feel free to explore any of them depending on your interests, but we
recommend starting with the ones marked with a “⭐”


  Example 1: nodal H1 FEM for the Laplace problem. ⭐
  Example 2: vector FEM for linear elasticity.
  Example 3: Nedelec H(curl) FEM for the definite Maxwell problem.
  Example 4: Raviart-Thomas H(div) FEM for the grad-div problem.
  Example 5: mixed pressure-velocity FEM for the Darcy problem.
  Example 6: non-conforming adaptive mesh refinement (AMR) for the Laplace problem.
  Example 7: Laplace problem on a surface (the unit sphere). ⭐
  Example 8: Discontinuous Petrov-Galerkin (DPG) for the Laplace problem.
  Example 9: Discontinuous Galerkin (DG) time-dependent advection. ⭐
  Example 10: time-dependent implicit nonlinear elasticity. ⭐
  Example 11: parallel Laplace eigensolver.
  Example 12: parallel linear elasticity eigensolver.
  Example 13: parallel Maxwell eigensolver.
  Example 14: Discontinuous Galerkin (DG) for the Laplace problem.
  Example 15: dynamic AMR for Laplace with prescribed time-dependent source. ⭐
  Example 16: time-dependent nonlinear heat equation.
  Example 17: Discontinuous Galerkin (DG) for linear elasticity.
  Example 18: Discontinuous Galerkin (DG) for the Euler equations.
  Example 19: incompressible nonlinear elasticity.


Most of the examples have a serial and a parallel version, illustrating the ease of transition and the minimal code changes between the two.

Many of the examples also have modifications that take advantage of optional third-party libraries such as PETSc, SUNDIALS and PUMI.

Beyond the examples, a number of miniapps are available that are more representative of the advanced usage of the library in physics/application codes. Some of the included miniapps are:


  Volta: simple electrostatics simulation code.
  Tesla: simple magnetostatics simulation code.
  Maxwell: transient electromagnetics simulation code.
  Joule: transient magnetics and Joule heating miniapp.
  Shaper: resolve material interfaces by mesh refinement. ⭐
  Mesh Explorer: visualize and manipulate meshes.
  Mesh Optimizer: optimize high-order meshes.


In addition, the sources for several external benchmark/proxy-apps build on top of MFEM are available:


  Laghos: high-order Lagrangian hydrodynamics miniapp. ⭐
  Mulard: multigroup thermal radiation diffusion mini application.


(Bonus #2) Create Your Own Simple Simulation

Modify the miniapps and example codes, either in your local copy on Cooley, or on your laptop to
create a simple simulation of your own. In both cases you should be able to edit the source code
and rebuild the binary simply with make.

For example, you can solve a steady-state heat conduction problem in 2D
and 3D using the shaper miniapp (modified for the cable shape) to define the mesh and ex1
or ex1p to solve it (modified to include separate coefficients for air and cable).

We want to see your creativity – the best simulations will enter for a chance to be
featured on MFEM’s gallery page!

Please consult the MFEM code documentation and
don’t hesitate to ask if you have any implementation questions.

To Get Credit / Points

To get points, please submit screenshots, simulation images and any additional material you have
generated via Show Your Work
using the hands-on activity name MFEM_HandsOn.">
	<meta property="og:url" content="http://localhost:4000/lessons/mfem_convergence/">
	<meta property="og:locale" content="en_EN">
	<meta property="og:type" content="website">
	<meta property="og:site_name" content="ATPESC 2018 Math Library Hands On Exercises">
	
	<meta property="article:author" content="https://www.facebook.com/phlow.media">


	
	<!-- Twitter -->
	<meta name="twitter:card" content="summary">
	<meta name="twitter:site" content="phlow">
	<meta name="twitter:creator" content="phlow">
	<meta name="twitter:title" content="Unstructured Meshing &amp; Discretization with MFEM">
	<meta name="twitter:description" content="At A Glance


  
    
      Questions
      Objectives
      Key Points
    
    
      What is a finite element method?
      Understand basic finite element machinery.
      Basis functions determinethe quality of the solution.
    
    
      What is a high order method?
      Understand how polynomialorder affects simulations.
      High order methods add moreunknowns on the same meshfor more precise solutions.
    
    
      What is convergence?
      Understand how convergence andconvergence rate are calculated.
      High order methods convergefaster for smooth solutions.
    
  


Note: To begin this lesson…

  Open the Answers Form
  Get into the directory containing the MFEM convergence example:
    cd HandsOnLessons/mfem_convergence
    
  


A Widely Applicable Equation

In this lesson, we demonstrate the discretization of a simple Poisson problem using
the MFEM library and examine the finite element approximation error
under uniform refinement. An example of this equation is steady-state heat
conduction.


  
    
      
      
    
  


Governing Equation

The Poisson Equation is a partial
differential equation (PDE) that can be used to model steady-state heat conduction,
electric potentials and gravitational fields. In mathematical terms …



where u is the potential field and f is the source function. This PDE is a generalization
of the Laplace Equation.

Finite Element Basics

To solve the above continuous equation using computers we need to
discretize it by introducing a finite
(discrete) number of unknowns to compute for.
In the Finite Element Method (FEM), this is
done using the concept of basis functions.

Instead of calculating the exact analytic solution u, consider approximating it by



where  are scalar unknown coefficients and  are known basis functions.
They are typically piecewise-polynomial functions which are only non-zero on small portions of the
computational mesh.


  
    
      
    
  


With finite elements, the mesh can be totally unstructured, curved and
non-conforming.


  
    
      
    
  


To solve for the unknown coefficients, we multiply Poisson’s equation by another (test)
basis function  and integrate by parts to obtain



for every basis function . (Here we are assuming homogeneous Dirichlet boundary
conditions corresponding, for example, to zero temperature on the whole boundary.)

Since the basis functions are known, we can rewrite (3) as



where







This is a  linear system that can be solved directly or
iteratively for the unknown coefficients. Note that we are free
to choose the basis functions  as we see fit.



Convergence Study Source Code

The mfem_convergence/ directory contains the convergence.cpp source code for solving the
Poisson problem using a variety of grids and orders. You can also view the code online on
GitHub.

To define the system we need to solve, we need three things. First, we need to define our
basis functions which live on the computational mesh.

   // order is the FEM basis functions polynomial order
   FiniteElementCollection *fec = new H1_FECollection(order, dim);

   // pmesh is the parallel computational mesh
   ParFiniteElementSpace *fespace = new ParFiniteElementSpace(pmesh, fec);


This defines a collection of H1 functions (meaning they have well-defined gradient) of
a given polynomial order on a parallel computational mesh pmesh. Next, we need to define
the integrals in Equation (5)

   ParBilinearForm *a = new ParBilinearForm(fespace);
   ConstantCoefficient one(1.0);
   a-&amp;gt;AddDomainIntegrator(new DiffusionIntegrator(one));
   a-&amp;gt;Assemble();


and Equation (6)

   // f_exact is a C function defining the source
   FunctionCoefficient f(f_exact);
   ParLinearForm *b = new ParLinearForm(fespace);
   b-&amp;gt;AddDomainIntegrator(new DomainLFIntegrator(f));
   b-&amp;gt;Assemble();


This defines the matrix A and the vector b. We then solve the linear
system for our solution vector x using AMG-preconditioned PCG iteration.

   // FEM -&amp;gt; Linear System
   HypreParMatrix A;
   Vector B, X;
   a-&amp;gt;FormLinearSystem(ess_tdof_list, x, *b, A, X, B);

   // AMG preconditioner
   HypreBoomerAMG *amg = new HypreBoomerAMG(A);
   amg-&amp;gt;SetPrintLevel(0);

   // PCG Krylov solver
   HyprePCG *pcg = new HyprePCG(A);
   pcg-&amp;gt;SetTol(1e-12);
   pcg-&amp;gt;SetMaxIter(200);
   pcg-&amp;gt;SetPrintLevel(0);
   pcg-&amp;gt;SetPreconditioner(*amg);

   // Solve the system A X = B
   pcg-&amp;gt;Mult(B, X);

   // Linear System -&amp;gt; FEM
   a-&amp;gt;RecoverFEMSolution(X, *b, x);


In this lesson we know what the exact solution is, so we can measure the amount of
error in our approximate solution in two ways:





We expect the error to behave like



where  is the mesh size,  is a mesh-independent constant and 
is the convergence rate.

Given approximations at two different mesh resolutions, we can  estimate the convergence rate as
follows ( doesn’t change when we refine the mesh and compare runs):



In code, this is implemented in a refinement loop as follows:

   double l2_err = x.ComputeL2Error(u);
   double h1_err = x.ComputeH1Error(&amp;amp;u, &amp;amp;u_grad, &amp;amp;one, 1.0, 1);
   pmesh-&amp;gt;GetCharacteristics(h_min, h_max, kappa_min, kappa_max);

   l2_rate = log(l2_err/l2_err_prev) / log(h_min/h_prev);
   h1_rate = log(h1_err/h1_err_prev) / log(h_min/h_prev);




Running the Convergence Study

The convergence study has the following options.

./convergence --help

Usage: ./convergence [options] ...
Options:
   -h, --help
	Print this help message and exit.
   -m &amp;lt;string&amp;gt;, --mesh &amp;lt;string&amp;gt;, current value: star.mesh
	Mesh file to use.
   -o &amp;lt;int&amp;gt;, --order &amp;lt;int&amp;gt;, current value: 1
	Finite element order (polynomial degree).
   -sc, --static-condensation, -no-sc, --no-static-condensation, current option: --no-static-condensation
	Enable static condensation.
   -r &amp;lt;int&amp;gt;, --refinements &amp;lt;int&amp;gt;, current value: 4
	Number of total uniform refinements
   -sr &amp;lt;int&amp;gt;, --serial-refinements &amp;lt;int&amp;gt;, current value: 2
	Maximum number of serial uniform refinements
   -f &amp;lt;double&amp;gt;, --frequency &amp;lt;double&amp;gt;, current value: 1
	Set the frequency for the exact solution.


Run 1 (Low order)

In this run, we will examine the error after seven uniform refinements in both the L2 and H1 norms using
first order (linear) basis functions. We use the star.mesh 2D mesh file.

./convergence -r 7
Options used:
   --mesh star.mesh
   --order 1
   --no-static-condensation
   --refinements 7
   --serial-refinements 2
   --frequency 1
----------------------------------------------------------------------------------------
DOFs            h               L^2 error       L^2 rate        H^1 error       H^1 rate
----------------------------------------------------------------------------------------
31              0.4876          0.3252          0               2.631           0
101             0.2438          0.09293         1.807           1.387           0.9229
361             0.1219          0.02393         1.957           0.7017          0.9836
1361            0.06095         0.006027        1.989           0.3518          0.996
5281            0.03048         0.00151         1.997           0.176           0.999
20801           0.01524         0.0003776       1.999           0.08803         0.9997
82561           0.007619        9.441e-05       2               0.04402         0.9999


Note that the L2 error is converging at a rate of 2 while the H1 error is only converging at a rate of 1.

Run 2 (High order)

Now consider the same run, only we are using 3rd order (cubic) basis functions instead.

./convergence -r 7 -o 3
Options used:
   --mesh star.mesh
   --order 3
   --no-static-condensation
   --refinements 7
   --serial-refinements 2
   --frequency 1
----------------------------------------------------------------------------------------
DOFs            h               L^2 error       L^2 rate        H^1 error       H^1 rate
----------------------------------------------------------------------------------------
211             0.4876          0.004777        0               0.118           0
781             0.2438          0.0003178       3.91            0.01576         2.905
3001            0.1219          2.008e-05       3.984           0.001995        2.982
11761           0.06095         1.258e-06       3.997           0.0002501       2.996
46561           0.03048         7.864e-08       4               3.129e-05       2.999
185281          0.01524         4.915e-09       4               3.912e-06       3
739201          0.007619        3.072e-10       4               4.891e-07       3


The L2 error is now converging at a rate of 4, and the H1 error is converging at a rate of 3.
This is because the exact solution in these runs is smooth, so higher-order methods
approximate it better.

Questions


  
  
  How many unknowns do we need in runs 1 and 2 to get four digits of accuracy?

  
    
    
      
          We need only 3001 unknowns compared to 82561 unknowns for the low-order method!

      
    
  



  
  
  Which method is more efficient: low-order or high-order?

  
    
    
      
          The high-order method is more efficient.

      
    
  


Run 3 (3D example)
The previous two runs used a 2D mesh in serial, but the same code can be used to run a 3D problem in parallel.

mpiexec -n 4 ./convergence -r 4 -o 2 -m inline-hex.mesh
Options used:
   --mesh inline-hex.mesh
   --order 2
   --no-static-condensation
   --refinements 4
   --serial-refinements 2
   --frequency 1
----------------------------------------------------------------------------------------
DOFs            h               L^2 error       L^2 rate        H^1 error       H^1 rate
----------------------------------------------------------------------------------------
729             0.25            0.001386        0               0.02215         0
4913            0.125           0.0001772       2.967           0.005532        2.002
35937           0.0625          2.227e-05       2.993           0.001377        2.007
274625          0.03125         2.787e-06       2.998           0.0003441       2


Questions

Experiment with different orders in 2D and 3D.


  
  
  What convergence rate will you expect in L2 and H1 for a given basis order p?

  
    
    
      
          For a smooth exact solution, the convergence rate in energy norm (H1) is p.
    Using the so-called Nitsche Trick, one can prove that we pick an additional order in L2,
    so the convergence rate there is p+1.

      
    
  




Out-Brief

We demonstrated the ease of implementing a order- and dimension-independent finite element
code in MFEM. We discussed the basics of the finite element method as well as demonstrated
the effect of the polynomial order of the basis functions on convergence rates.

Further Reading

For more information, visit the MFEM website, http://mfem.org, including the


  Features,
  Examples,
  Publications
  Finite Elements, and
  Meshing pages.


You may also be interested in visiting the websites of the related GLVis,
CEED, and BLAST projects.



Evening Hands On

The evening hands on exercise will be dedicated on getting more experience with MFEM and on reviewing
finite element discretization methods for additional physics.

(Bonus #1) Install MFEM + GLVis On Your Laptop

  Follow the building instructions here: http://mfem.org/building/.
  You should be able to download &amp;amp; install serial version of MFEM in 5min (there are no external dependencies).
  Parallel versions of MFEM requires installing hypre and METIS (also discussed above).
  Alternatively, if you already have Spack, you can build with: spack install mfem glvis.
  GLVis requires a recent version of XQuartz on Mac laptops.


Review And Run Additional Example Codes &amp;amp; Miniapps

MFEM includes a number of well-documented example codes &amp;amp; miniapps that can be
used as tutorials, as well as simple starting points for user applications.

These examples and miniapps are available in the mfem/ subdirectory of your copy of
HandsOnLessons/mfem_convergence or as top-level sub-directories in the MFEM
source code.

The full list of examples is below. Feel free to explore any of them depending on your interests, but we
recommend starting with the ones marked with a “⭐”


  Example 1: nodal H1 FEM for the Laplace problem. ⭐
  Example 2: vector FEM for linear elasticity.
  Example 3: Nedelec H(curl) FEM for the definite Maxwell problem.
  Example 4: Raviart-Thomas H(div) FEM for the grad-div problem.
  Example 5: mixed pressure-velocity FEM for the Darcy problem.
  Example 6: non-conforming adaptive mesh refinement (AMR) for the Laplace problem.
  Example 7: Laplace problem on a surface (the unit sphere). ⭐
  Example 8: Discontinuous Petrov-Galerkin (DPG) for the Laplace problem.
  Example 9: Discontinuous Galerkin (DG) time-dependent advection. ⭐
  Example 10: time-dependent implicit nonlinear elasticity. ⭐
  Example 11: parallel Laplace eigensolver.
  Example 12: parallel linear elasticity eigensolver.
  Example 13: parallel Maxwell eigensolver.
  Example 14: Discontinuous Galerkin (DG) for the Laplace problem.
  Example 15: dynamic AMR for Laplace with prescribed time-dependent source. ⭐
  Example 16: time-dependent nonlinear heat equation.
  Example 17: Discontinuous Galerkin (DG) for linear elasticity.
  Example 18: Discontinuous Galerkin (DG) for the Euler equations.
  Example 19: incompressible nonlinear elasticity.


Most of the examples have a serial and a parallel version, illustrating the ease of transition and the minimal code changes between the two.

Many of the examples also have modifications that take advantage of optional third-party libraries such as PETSc, SUNDIALS and PUMI.

Beyond the examples, a number of miniapps are available that are more representative of the advanced usage of the library in physics/application codes. Some of the included miniapps are:


  Volta: simple electrostatics simulation code.
  Tesla: simple magnetostatics simulation code.
  Maxwell: transient electromagnetics simulation code.
  Joule: transient magnetics and Joule heating miniapp.
  Shaper: resolve material interfaces by mesh refinement. ⭐
  Mesh Explorer: visualize and manipulate meshes.
  Mesh Optimizer: optimize high-order meshes.


In addition, the sources for several external benchmark/proxy-apps build on top of MFEM are available:


  Laghos: high-order Lagrangian hydrodynamics miniapp. ⭐
  Mulard: multigroup thermal radiation diffusion mini application.


(Bonus #2) Create Your Own Simple Simulation

Modify the miniapps and example codes, either in your local copy on Cooley, or on your laptop to
create a simple simulation of your own. In both cases you should be able to edit the source code
and rebuild the binary simply with make.

For example, you can solve a steady-state heat conduction problem in 2D
and 3D using the shaper miniapp (modified for the cable shape) to define the mesh and ex1
or ex1p to solve it (modified to include separate coefficients for air and cable).

We want to see your creativity – the best simulations will enter for a chance to be
featured on MFEM’s gallery page!

Please consult the MFEM code documentation and
don’t hesitate to ask if you have any implementation questions.

To Get Credit / Points

To get points, please submit screenshots, simulation images and any additional material you have
generated via Show Your Work
using the hands-on activity name MFEM_HandsOn.">
	
	

	<link type="text/plain" rel="author" href="http://localhost:4000/humans.txt">

	

	

	<link rel="icon" sizes="32x32" href="http://localhost:4000/assets/img/favicon-32x32.png">

	<link rel="icon" sizes="192x192" href="http://localhost:4000/assets/img/touch-icon-192x192.png">

	<link rel="apple-touch-icon-precomposed" sizes="180x180" href="http://localhost:4000/assets/img/apple-touch-icon-180x180-precomposed.png">

	<link rel="apple-touch-icon-precomposed" sizes="152x152" href="http://localhost:4000/assets/img/apple-touch-icon-152x152-precomposed.png">

	<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://localhost:4000/assets/img/apple-touch-icon-144x144-precomposed.png">

	<link rel="apple-touch-icon-precomposed" sizes="120x120" href="http://localhost:4000/assets/img/apple-touch-icon-120x120-precomposed.png">

	<link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://localhost:4000/assets/img/apple-touch-icon-114x114-precomposed.png">

	
	<link rel="apple-touch-icon-precomposed" sizes="76x76" href="http://localhost:4000/assets/img/apple-touch-icon-76x76-precomposed.png">

	<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/assets/img/apple-touch-icon-72x72-precomposed.png">

	<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/assets/img/apple-touch-icon-precomposed.png">	

	<meta name="msapplication-TileImage" content="http://localhost:4000/assets/img/msapplication_tileimage.png">

	<meta name="msapplication-TileColor" content="#fabb00">


	

        
	   <!-- MathJax Config
                    CommonHTML: {
                        scale: 200
                    }
            <script type="text/x-mathjax-config">
                MathJax.Hub.Config({
                    displayAlign: "left"
                });
            </script>
            -->
            <script type="text/javascript" async
                src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async>
            </script>
            <script type="text/x-mathjax-config">
                MathJax.Hub.Config({
                    TeX: { 
                        equationNumbers: {  autoNumber: "all"  }
                    }
                });
            </script>
        

</head>
<body id="top-of-page" class="page-fullwidth">
        

	
	
<div id="navigation" class="sticky">
  <nav class="top-bar" role="navigation" data-topbar>
    <ul class="title-area">
      <li class="name">
      <h1 class="show-for-small-only"><a href="http://localhost:4000" class="icon-tree"> ATPESC 2018 Math Library Hands On Exercises</a></h1>
    </li>
       <!-- Remove the class "menu-icon" to get rid of menu icon. Take out "Menu" to just have icon alone -->
      <li class="toggle-topbar menu-icon"><a href="#"><span>Nav</span></a></li>
    </ul>
    <section class="top-bar-section">

      <ul class="right">
        
              

              

          
          
        
              

              

          
          
        
              

              

          
          
        
              

              

          
          
        
        
      </ul>

      <ul class="left">
        
              

              

          
          

            
            

              <li class="has-dropdown">
                <a  href="http://localhost:4000/">Intro</a>

                  <ul class="dropdown">
                    

                      

                      <li><a  href="http://localhost:4000/about_your_day/">About Your Day</a></li>
                    

                      

                      <li><a  href="http://localhost:4000/setup_instructions/">Setup Instructions</a></li>
                    

                      

                      <li><a  href="http://localhost:4000/atpesc_2018_agenda/">Today&#39;s Agenda</a></li>
                    

                      

                      <li><a  href="https://www.alcf.anl.gov/user-guides" target="_blank">ALCF User Guides</a></li>
                    

                      

                      <li><a  href="https://hangouts.google.com/group/wuWDDdPe4mX1u0v83" target="_blank">Open Chat</a></li>
                    

                      

                      <li><a  href="http://localhost:4000/pages/one_on_one_schedule.html">One-on-One Schedule</a></li>
                    

                      

                      <li><a  href="https://goo.gl/forms/B7UFpBvEOJbC58oJ2" target="_blank">Submit a Show Your Work</a></li>
                    
                  </ul>

              </li>
              <li class="divider"></li>
            
          
        
              

              

          
          

            
            

              <li class="has-dropdown">
                <a  href="http://localhost:4000/lessons/">Lessons</a>

                  <ul class="dropdown">
                    

                      

                      <li><a  href="http://localhost:4000/lessons/hand_coded_heat/">Hand Coded Heat</a></li>
                    

                      

                      <li><a  href="http://localhost:4000/lessons/mfem_convergence/">Meshing and Discretization (MFEM)</a></li>
                    

                      

                      <li><a  href="http://localhost:4000/lessons/pumi/">MFEM+PUMI Adaptive Workflow</a></li>
                    

                      

                      <li><a  href="http://localhost:4000/lessons/time_integrators/">Time Integration &amp; Non-Linear Solvers</a></li>
                    

                      

                      <li><a  href="http://localhost:4000/lessons/krylov_amg/">Krylov Solvers and Algebraic Multigrid</a></li>
                    

                      

                      <li><a  href="http://localhost:4000/lessons/superlu_mfem/">Sparse Direct Solvers</a></li>
                    

                      

                      <li><a  href="http://localhost:4000/lessons/adjoint/">Numerical Optimization (Adjoint)</a></li>
                    

                      

                      <li><a  href="http://localhost:4000/lessons/obstacle_tao">Numerical Optimization</a></li>
                    
                  </ul>

              </li>
              <li class="divider"></li>
            
          
        
              

              

          
          

            
            

              <li class="has-dropdown">
                <a  href="https://fastmath-scidac.org/software-catalog.html" target="_blank">Packages</a>

                  <ul class="dropdown">
                    

                      

                      <li><a  href="http://mfem.org" target="_blank">MFEM</a></li>
                    

                      

                      <li><a  href="https://www.scorec.rpi.edu/pumi" target="_blank">PUMI</a></li>
                    

                      

                      <li><a  href="https://www.mcs.anl.gov/petsc/" target="_blank">PETSc</a></li>
                    

                      

                      <li><a  href="https://computation.llnl.gov/projects/hypre-scalable-linear-solvers-multigrid-methods" target="_blank">HYPRE</a></li>
                    

                      

                      <li><a  href="http://crd-legacy.lbl.gov/~xiaoye/SuperLU" target="_blank">SuperLU</a></li>
                    

                      

                      <li><a  href="http://www.mcs.anl.gov/research/projects/tao/tao-deprecated/index.html" target="_blank">Tao</a></li>
                    
                  </ul>

              </li>
              <li class="divider"></li>
            
          
        
              

              

          
          

            
            

              <li class="has-dropdown">
                <a  href="http://localhost:4000/contributing_guide/">Contributing</a>

                  <ul class="dropdown">
                    

                      

                      <li><a  href="http://localhost:4000/contributing_guide/">Contributing Guide</a></li>
                    

                      

                      <li><a  href="http://localhost:4000/info/">Why the new theme?</a></li>
                    

                      

                      <li><a  href="http://localhost:4000/headers/">Many Header Styles</a></li>
                    

                      

                      <li><a  href="http://localhost:4000/design/">Many Design Options</a></li>
                    

                      

                      <li><a  href="http://localhost:4000/documentation/">Full Documentation</a></li>
                    
                  </ul>

              </li>
              <li class="divider"></li>
            
          
        
        
      </ul>
    </section>
  </nav>
</div><!-- /#navigation -->

	

	

<div id="masthead">
	<div class="row">
		<div class="small-12 columns">
			<a id="logo" href="http://localhost:4000/" title="ATPESC 2018 Math Library Hands On Exercises – So my code will see the future">
				<img src="http://localhost:4000/assets/img/logo.png" alt="ATPESC 2018 Math Library Hands On Exercises – So my code will see the future">
			</a>
		</div><!-- /.small-12.columns -->
	</div><!-- /.row -->
</div><!-- /#masthead -->










	


<div class="row t30">
	<div class="medium-12 columns">
		<article>
			<header>
				<p class="subheadline">Finite Elements and Convergence</p>
				<h1>Unstructured Meshing & Discretization with MFEM</h1>
			</header>

			

			<h2 id="at-a-glance">At A Glance</h2>

<table>
  <tbody>
    <tr>
      <td>Questions</td>
      <td>Objectives</td>
      <td>Key Points</td>
    </tr>
    <tr>
      <td>What is a finite element method?</td>
      <td>Understand basic finite element machinery.</td>
      <td>Basis functions determine<br />the quality of the solution.</td>
    </tr>
    <tr>
      <td>What is a high order method?</td>
      <td>Understand how polynomial<br />order affects simulations.</td>
      <td>High order methods add more<br />unknowns on the same mesh<br />for more precise solutions.</td>
    </tr>
    <tr>
      <td>What is <em>convergence</em>?</td>
      <td>Understand how convergence and<br />convergence rate are calculated.</td>
      <td>High order methods converge<br />faster for smooth solutions.</td>
    </tr>
  </tbody>
</table>

<p><strong>Note:</strong> To begin this lesson…</p>
<ul>
  <li><a href="https://docs.google.com/forms/d/e/1FAIpQLScs9reOCfuD1CfbQ-m458MDyvwiTCRXEcp1XCQukaf5tP_uSQ/viewform?usp=sf_link" target="_blank">Open the Answers Form</a></li>
  <li>Get into the directory containing the MFEM <a href="https://github.com/mfem/mfem/blob/atpesc-dev/examples/atpesc/mfem/convergence.cpp">convergence</a> example:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd HandsOnLessons/mfem_convergence
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="a-widely-applicable-equation">A Widely Applicable Equation</h2>

<p>In this lesson, we demonstrate the discretization of a simple Poisson problem using
the <a href="http://mfem.org">MFEM library</a> and examine the finite element approximation error
under uniform refinement. An example of this equation is steady-state <a href="../hand_coded_heat/">heat</a>
<a href="../time_integrators/">conduction</a>.</p>

<table>
  <tbody>
    <tr>
      <td><a href="/lessons/mfem_convergence/ex8.png"><img src="ex8.png" /></a></td>
      <td><a href="/lessons/mfem_convergence/diffusion.png"><img src="diffusion.png" /></a></td>
    </tr>
  </tbody>
</table>

<h3 id="governing-equation">Governing Equation</h3>

<p>The <a href="https://en.wikipedia.org/wiki/Poisson's_equation"><em>Poisson Equation</em></a> is a partial
differential equation (PDE) that can be used to model steady-state heat conduction,
electric potentials and gravitational fields. In mathematical terms …</p>

<script type="math/tex; mode=display">-\nabla^2u = f</script>

<p>where <em>u</em> is the potential field and <em>f</em> is the source function. This PDE is a generalization
of the <a href="https://en.wikipedia.org/wiki/Laplace%27s_equation"><em>Laplace Equation</em></a>.</p>

<h3 id="finite-element-basics">Finite Element Basics</h3>

<p>To solve the above continuous equation using computers we need to
<a href="https://en.wikipedia.org/wiki/Discretization">discretize</a> it by introducing a finite
(discrete) number of unknowns to compute for.
In the <a href="https://en.wikipedia.org/wiki/Finite_element_method"><em>Finite Element Method</em></a> (FEM), this is
done using the concept of <em>basis functions</em>.</p>

<p>Instead of calculating the exact analytic solution <em>u</em>, consider approximating it by</p>

<script type="math/tex; mode=display">u \approx \sum_{j=1}^n c_j \phi_j</script>

<p>where <script type="math/tex">c_j</script> are scalar unknown coefficients and <script type="math/tex">\phi_j</script> are known <em>basis functions</em>.
They are typically piecewise-polynomial functions which are only non-zero on small portions of the
computational mesh.</p>

<table>
  <tbody>
    <tr>
      <td><a href="/lessons/mfem_convergence/phi.png"><img src="phi.png" width="400" /></a></td>
    </tr>
  </tbody>
</table>

<p>With finite elements, the mesh can be totally unstructured, curved and
non-conforming.</p>

<table>
  <tbody>
    <tr>
      <td><a href="/lessons/mfem_convergence/mesh.png"><img src="mesh.png" width="300" /></a></td>
    </tr>
  </tbody>
</table>

<p>To solve for the unknown coefficients, we multiply Poisson’s equation by another (test)
basis function <script type="math/tex">\phi_i</script> and integrate by parts to obtain</p>

<script type="math/tex; mode=display">\sum_{j=1}^n\int_\Omega c_j \nabla \phi_j \cdot \nabla \phi_i dV = \int_\Omega f \phi_i</script>

<p>for every basis function <script type="math/tex">\phi_i</script>. (Here we are assuming homogeneous Dirichlet boundary
conditions corresponding, for example, to zero temperature on the whole boundary.)</p>

<p>Since the basis functions are known, we can rewrite (3) as</p>

<script type="math/tex; mode=display">\mathbf{Ax} = \mathbf{b}</script>

<p>where</p>

<script type="math/tex; mode=display">A_{ij} = \int_\Omega \nabla \phi_i \cdot \nabla \phi_j dV</script>

<script type="math/tex; mode=display">b_i = \int_\Omega f \phi_i dV</script>

<script type="math/tex; mode=display">x_j = c_j</script>

<p>This is a <script type="math/tex">n \times n</script> linear system that can be solved <a href="../superlu_mfem/">directly</a> or
<a href="../krylov_amg/">iteratively</a> for the unknown coefficients. Note that we are free
to choose the basis functions <script type="math/tex">\phi_i</script> as we see fit.</p>

<hr />

<h2 id="convergence-study-source-code">Convergence Study Source Code</h2>

<p>The <code class="highlighter-rouge">mfem_convergence/</code> directory contains the <code class="highlighter-rouge">convergence.cpp</code> source code for solving the
Poisson problem using a variety of grids and orders. You can also view the code online on
<a href="https://github.com/mfem/mfem/blob/atpesc-dev/examples/atpesc/mfem/convergence.cpp">GitHub</a>.</p>

<p>To define the system we need to solve, we need three things. First, we need to define our
basis functions which live on the computational mesh.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="c1">// order is the FEM basis functions polynomial order</span>
   <span class="n">FiniteElementCollection</span> <span class="o">*</span><span class="n">fec</span> <span class="o">=</span> <span class="k">new</span> <span class="n">H1_FECollection</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>

   <span class="c1">// pmesh is the parallel computational mesh</span>
   <span class="n">ParFiniteElementSpace</span> <span class="o">*</span><span class="n">fespace</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ParFiniteElementSpace</span><span class="p">(</span><span class="n">pmesh</span><span class="p">,</span> <span class="n">fec</span><span class="p">);</span>
</code></pre></div></div>

<p>This defines a collection of H1 functions (meaning they have well-defined gradient) of
a given polynomial order on a parallel computational mesh <code class="highlighter-rouge">pmesh</code>. Next, we need to define
the integrals in Equation (5)</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="n">ParBilinearForm</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ParBilinearForm</span><span class="p">(</span><span class="n">fespace</span><span class="p">);</span>
   <span class="n">ConstantCoefficient</span> <span class="n">one</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
   <span class="n">a</span><span class="o">-&gt;</span><span class="n">AddDomainIntegrator</span><span class="p">(</span><span class="k">new</span> <span class="n">DiffusionIntegrator</span><span class="p">(</span><span class="n">one</span><span class="p">));</span>
   <span class="n">a</span><span class="o">-&gt;</span><span class="n">Assemble</span><span class="p">();</span>
</code></pre></div></div>

<p>and Equation (6)</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="c1">// f_exact is a C function defining the source</span>
   <span class="n">FunctionCoefficient</span> <span class="n">f</span><span class="p">(</span><span class="n">f_exact</span><span class="p">);</span>
   <span class="n">ParLinearForm</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ParLinearForm</span><span class="p">(</span><span class="n">fespace</span><span class="p">);</span>
   <span class="n">b</span><span class="o">-&gt;</span><span class="n">AddDomainIntegrator</span><span class="p">(</span><span class="k">new</span> <span class="n">DomainLFIntegrator</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
   <span class="n">b</span><span class="o">-&gt;</span><span class="n">Assemble</span><span class="p">();</span>
</code></pre></div></div>

<p>This defines the matrix A and the vector b. We then solve the linear
system for our solution vector x using <a href="../krylov_amg/">AMG-preconditioned</a> PCG iteration.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="c1">// FEM -&gt; Linear System</span>
   <span class="n">HypreParMatrix</span> <span class="n">A</span><span class="p">;</span>
   <span class="n">Vector</span> <span class="n">B</span><span class="p">,</span> <span class="n">X</span><span class="p">;</span>
   <span class="n">a</span><span class="o">-&gt;</span><span class="n">FormLinearSystem</span><span class="p">(</span><span class="n">ess_tdof_list</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">B</span><span class="p">);</span>

   <span class="c1">// AMG preconditioner</span>
   <span class="n">HypreBoomerAMG</span> <span class="o">*</span><span class="n">amg</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HypreBoomerAMG</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
   <span class="n">amg</span><span class="o">-&gt;</span><span class="n">SetPrintLevel</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

   <span class="c1">// PCG Krylov solver</span>
   <span class="n">HyprePCG</span> <span class="o">*</span><span class="n">pcg</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HyprePCG</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
   <span class="n">pcg</span><span class="o">-&gt;</span><span class="n">SetTol</span><span class="p">(</span><span class="mf">1e-12</span><span class="p">);</span>
   <span class="n">pcg</span><span class="o">-&gt;</span><span class="n">SetMaxIter</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
   <span class="n">pcg</span><span class="o">-&gt;</span><span class="n">SetPrintLevel</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
   <span class="n">pcg</span><span class="o">-&gt;</span><span class="n">SetPreconditioner</span><span class="p">(</span><span class="o">*</span><span class="n">amg</span><span class="p">);</span>

   <span class="c1">// Solve the system A X = B</span>
   <span class="n">pcg</span><span class="o">-&gt;</span><span class="n">Mult</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">X</span><span class="p">);</span>

   <span class="c1">// Linear System -&gt; FEM</span>
   <span class="n">a</span><span class="o">-&gt;</span><span class="n">RecoverFEMSolution</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
</code></pre></div></div>

<p>In this lesson we know what the exact solution is, so we can measure the amount of
error in our approximate solution in two ways:</p>

<script type="math/tex; mode=display">\left \| u_{\mbox{exact}} - u_{\mbox{h}} \right \|_{L_2}^2 = \int_\Omega \left| u_{\mbox{exact}} - u_{\mbox{h}} \right |^2</script>

<script type="math/tex; mode=display">\left \| u_{\mbox{exact}} - u_{\mbox{h}} \right \|_{H^1}^2 = \left \| u_{\mbox{exact}} - u_{\mbox{h}} \right \|_{L_2}^2 + \left \| \nabla u_{\mbox{exact}} - \nabla u_{\mbox{h}} \right \|_{L_2}^2</script>

<p>We expect the error to behave like</p>

<script type="math/tex; mode=display">\left \| u_{\mbox{exact}} - u_{\mbox{h}} \right \|_{L_2} \leq Ch^{r}</script>

<p>where <script type="math/tex">h</script> is the mesh size, <script type="math/tex">C</script> is a mesh-independent constant and <script type="math/tex">r</script>
is the <a href="https://en.wikipedia.org/wiki/Rate_of_convergence"><em>convergence rate</em></a>.</p>

<p>Given approximations at two different mesh resolutions, we can  estimate the convergence rate as
follows (<script type="math/tex">C</script> doesn’t change when we refine the mesh and compare runs):</p>

<script type="math/tex; mode=display">r \approx \frac{\log\ \frac{ \left \| u_{\mbox{exact}} - u_{h_{\mbox{new}}} \right \|_{L_2}}{\left \| u_{\mbox{exact}} - u_{h_{\mbox{old}}} \right \|_{L_2}}}{ \log \frac{h_{\mbox{new}}}{h_{\mbox{old}}}}</script>

<p>In code, this is implemented in a refinement loop as follows:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="kt">double</span> <span class="n">l2_err</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">ComputeL2Error</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
   <span class="kt">double</span> <span class="n">h1_err</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">ComputeH1Error</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u_grad</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">one</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
   <span class="n">pmesh</span><span class="o">-&gt;</span><span class="n">GetCharacteristics</span><span class="p">(</span><span class="n">h_min</span><span class="p">,</span> <span class="n">h_max</span><span class="p">,</span> <span class="n">kappa_min</span><span class="p">,</span> <span class="n">kappa_max</span><span class="p">);</span>

   <span class="n">l2_rate</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">l2_err</span><span class="o">/</span><span class="n">l2_err_prev</span><span class="p">)</span> <span class="o">/</span> <span class="n">log</span><span class="p">(</span><span class="n">h_min</span><span class="o">/</span><span class="n">h_prev</span><span class="p">);</span>
   <span class="n">h1_rate</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">h1_err</span><span class="o">/</span><span class="n">h1_err_prev</span><span class="p">)</span> <span class="o">/</span> <span class="n">log</span><span class="p">(</span><span class="n">h_min</span><span class="o">/</span><span class="n">h_prev</span><span class="p">);</span>
</code></pre></div></div>

<hr />

<h2 id="running-the-convergence-study">Running the Convergence Study</h2>

<p>The convergence study has the following options.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./convergence --help

Usage: ./convergence [options] ...
Options:
   -h, --help
	Print this help message and exit.
   -m &lt;string&gt;, --mesh &lt;string&gt;, current value: star.mesh
	Mesh file to use.
   -o &lt;int&gt;, --order &lt;int&gt;, current value: 1
	Finite element order (polynomial degree).
   -sc, --static-condensation, -no-sc, --no-static-condensation, current option: --no-static-condensation
	Enable static condensation.
   -r &lt;int&gt;, --refinements &lt;int&gt;, current value: 4
	Number of total uniform refinements
   -sr &lt;int&gt;, --serial-refinements &lt;int&gt;, current value: 2
	Maximum number of serial uniform refinements
   -f &lt;double&gt;, --frequency &lt;double&gt;, current value: 1
	Set the frequency for the exact solution.
</code></pre></div></div>

<h3 id="run-1-low-order">Run 1 (Low order)</h3>

<p>In this run, we will examine the error after seven uniform refinements in both the L2 and H1 norms using
first order (linear) basis functions. We use the <code class="highlighter-rouge">star.mesh</code> 2D mesh file.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./convergence -r 7
Options used:
   --mesh star.mesh
   --order 1
   --no-static-condensation
   --refinements 7
   --serial-refinements 2
   --frequency 1
----------------------------------------------------------------------------------------
DOFs            h               L^2 error       L^2 rate        H^1 error       H^1 rate
----------------------------------------------------------------------------------------
31              0.4876          0.3252          0               2.631           0
101             0.2438          0.09293         1.807           1.387           0.9229
361             0.1219          0.02393         1.957           0.7017          0.9836
1361            0.06095         0.006027        1.989           0.3518          0.996
5281            0.03048         0.00151         1.997           0.176           0.999
20801           0.01524         0.0003776       1.999           0.08803         0.9997
82561           0.007619        9.441e-05       2               0.04402         0.9999
</code></pre></div></div>

<p>Note that the L2 error is converging at a rate of 2 while the H1 error is only converging at a rate of 1.</p>

<h3 id="run-2-high-order">Run 2 (High order)</h3>

<p>Now consider the same run, only we are using 3rd order (cubic) basis functions instead.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./convergence -r 7 -o 3
Options used:
   --mesh star.mesh
   --order 3
   --no-static-condensation
   --refinements 7
   --serial-refinements 2
   --frequency 1
----------------------------------------------------------------------------------------
DOFs            h               L^2 error       L^2 rate        H^1 error       H^1 rate
----------------------------------------------------------------------------------------
211             0.4876          0.004777        0               0.118           0
781             0.2438          0.0003178       3.91            0.01576         2.905
3001            0.1219          2.008e-05       3.984           0.001995        2.982
11761           0.06095         1.258e-06       3.997           0.0002501       2.996
46561           0.03048         7.864e-08       4               3.129e-05       2.999
185281          0.01524         4.915e-09       4               3.912e-06       3
739201          0.007619        3.072e-10       4               4.891e-07       3
</code></pre></div></div>

<p>The L2 error is now converging at a rate of 4, and the H1 error is converging at a rate of 3.
This is because the exact solution in these runs is smooth, so higher-order methods
approximate it better.</p>

<h4 id="questions">Questions</h4>

<div class="qanda">
  
  <input id="qanda_toggle1" type="checkbox" unchecked="" />
  <label class="qanda" for="qanda_toggle1" style="font-size:150%">How many unknowns do we need in runs 1 and 2 to get four digits of accuracy?
</label>
  <div id="qanda_expand1">
    <style>
      #qanda_toggle1:checked ~ #qanda_expand1 {
        
        
        
        
            height: 10vmin;
        
      }
    </style>
    <section>
      
          <p>We need only 3001 unknowns compared to 82561 unknowns for the low-order method!</p>

      
    </section>
  </div>
</div>

<div class="qanda">
  
  <input id="qanda_toggle2" type="checkbox" unchecked="" />
  <label class="qanda" for="qanda_toggle2" style="font-size:150%">Which method is more efficient: low-order or high-order?
</label>
  <div id="qanda_expand2">
    <style>
      #qanda_toggle2:checked ~ #qanda_expand2 {
        
        
        
        
            height: 10vmin;
        
      }
    </style>
    <section>
      
          <p>The high-order method is more efficient.</p>

      
    </section>
  </div>
</div>

<h3 id="run-3-3d-example">Run 3 (3D example)</h3>
<p>The previous two runs used a 2D mesh in serial, but the same code can be used to run a 3D problem in parallel.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mpiexec -n 4 ./convergence -r 4 -o 2 -m inline-hex.mesh
Options used:
   --mesh inline-hex.mesh
   --order 2
   --no-static-condensation
   --refinements 4
   --serial-refinements 2
   --frequency 1
----------------------------------------------------------------------------------------
DOFs            h               L^2 error       L^2 rate        H^1 error       H^1 rate
----------------------------------------------------------------------------------------
729             0.25            0.001386        0               0.02215         0
4913            0.125           0.0001772       2.967           0.005532        2.002
35937           0.0625          2.227e-05       2.993           0.001377        2.007
274625          0.03125         2.787e-06       2.998           0.0003441       2
</code></pre></div></div>

<h4 id="questions-1">Questions</h4>

<p>Experiment with different orders in 2D and 3D.</p>

<div class="qanda">
  
  <input id="qanda_toggle3" type="checkbox" unchecked="" />
  <label class="qanda" for="qanda_toggle3" style="font-size:150%">What convergence rate will you expect in L2 and H1 for a given basis order <em>p</em>?
</label>
  <div id="qanda_expand3">
    <style>
      #qanda_toggle3:checked ~ #qanda_expand3 {
        
        
        
        
            height: 10vmin;
        
      }
    </style>
    <section>
      
          <p>For a smooth exact solution, the convergence rate in energy norm (H1) is <em>p</em>.
    Using the so-called <em>Nitsche Trick</em>, one can prove that we pick an additional order in L2,
    so the convergence rate there is <em>p+1</em>.</p>

      
    </section>
  </div>
</div>

<hr />

<h2 id="out-brief">Out-Brief</h2>

<p>We demonstrated the ease of implementing a order- and dimension-independent finite element
code in MFEM. We discussed the basics of the finite element method as well as demonstrated
the effect of the polynomial order of the basis functions on convergence rates.</p>

<h3 id="further-reading">Further Reading</h3>

<p>For more information, visit the MFEM website, <a href="http://mfem.org">http://mfem.org</a>, including the</p>

<ul>
  <li><a href="http://mfem.org/features">Features</a>,</li>
  <li><a href="http://mfem.org/examples/">Examples</a>,</li>
  <li><a href="http://mfem.org/publications/">Publications</a></li>
  <li><a href="http://mfem.org/fem/">Finite Elements</a>, and</li>
  <li><a href="http://mfem.org/meshing">Meshing</a> pages.</li>
</ul>

<p>You may also be interested in visiting the websites of the related <a href="http://glvis.org">GLVis</a>,
<a href="http://ceed.exascaleproject.org">CEED</a>, and <a href="https://computation.llnl.gov/projects/blast">BLAST</a> projects.</p>

<hr />

<h3 id="evening-hands-on">Evening Hands On</h3>

<p>The evening hands on exercise will be dedicated on getting more experience with MFEM and on reviewing
finite element discretization methods for additional physics.</p>

<h5 id="bonus-1-install-mfem--glvis-on-your-laptop">(Bonus #1) Install MFEM + GLVis On Your Laptop</h5>
<ul>
  <li>Follow the building instructions here: <a href="http://mfem.org/building/">http://mfem.org/building/</a>.</li>
  <li>You should be able to download &amp; install serial version of MFEM in 5min (there are no external dependencies).</li>
  <li>Parallel versions of MFEM requires installing hypre and METIS (also discussed above).</li>
  <li>Alternatively, if you already have Spack, you can build with: <code class="highlighter-rouge">spack install mfem glvis</code>.</li>
  <li>GLVis requires a recent version of XQuartz on Mac laptops.</li>
</ul>

<h5 id="review-and-run-additional-example-codes--miniapps">Review And Run Additional Example Codes &amp; Miniapps</h5>

<p>MFEM includes a number of well-documented <a href="http://mfem.org/examples">example codes &amp; miniapps</a> that can be
used as tutorials, as well as simple starting points for user applications.</p>

<p>These examples and miniapps are available in the <code class="highlighter-rouge">mfem/</code> subdirectory of your copy of
<code class="highlighter-rouge">HandsOnLessons/mfem_convergence</code> or as top-level sub-directories in the MFEM
source code.</p>

<p>The full list of examples is below. Feel free to explore any of them depending on your interests, but we
recommend starting with the ones marked with a “⭐”</p>

<ul>
  <li><a href="http://mfem.github.io/doxygen/html/ex1_8cpp_source.html">Example 1</a>: nodal H1 FEM for the Laplace problem. ⭐</li>
  <li><a href="http://mfem.github.io/doxygen/html/ex2_8cpp_source.html">Example 2</a>: vector FEM for linear elasticity.</li>
  <li><a href="http://mfem.github.io/doxygen/html/ex3_8cpp_source.html">Example 3</a>: Nedelec H(curl) FEM for the definite Maxwell problem.</li>
  <li><a href="http://mfem.github.io/doxygen/html/ex4_8cpp_source.html">Example 4</a>: Raviart-Thomas H(div) FEM for the grad-div problem.</li>
  <li><a href="http://mfem.github.io/doxygen/html/ex5_8cpp_source.html">Example 5</a>: mixed pressure-velocity FEM for the Darcy problem.</li>
  <li><a href="http://mfem.github.io/doxygen/html/ex6_8cpp_source.html">Example 6</a>: non-conforming adaptive mesh refinement (AMR) for the Laplace problem.</li>
  <li><a href="http://mfem.github.io/doxygen/html/ex7_8cpp_source.html">Example 7</a>: Laplace problem on a surface (the unit sphere). ⭐</li>
  <li><a href="http://mfem.github.io/doxygen/html/ex8_8cpp_source.html">Example 8</a>: Discontinuous Petrov-Galerkin (DPG) for the Laplace problem.</li>
  <li><a href="http://mfem.github.io/doxygen/html/ex9_8cpp_source.html">Example 9</a>: Discontinuous Galerkin (DG) time-dependent advection. ⭐</li>
  <li><a href="http://mfem.github.io/doxygen/html/ex10_8cpp_source.html">Example 10</a>: time-dependent implicit nonlinear elasticity. ⭐</li>
  <li><a href="http://mfem.github.io/doxygen/html/ex11p_8cpp_source.html">Example 11</a>: parallel Laplace eigensolver.</li>
  <li><a href="http://mfem.github.io/doxygen/html/ex12p_8cpp_source.html">Example 12</a>: parallel linear elasticity eigensolver.</li>
  <li><a href="http://mfem.github.io/doxygen/html/ex13p_8cpp_source.html">Example 13</a>: parallel Maxwell eigensolver.</li>
  <li><a href="http://mfem.github.io/doxygen/html/ex14_8cpp_source.html">Example 14</a>: Discontinuous Galerkin (DG) for the Laplace problem.</li>
  <li><a href="http://mfem.github.io/doxygen/html/ex15_8cpp_source.html">Example 15</a>: dynamic AMR for Laplace with prescribed time-dependent source. ⭐</li>
  <li><a href="http://mfem.github.io/doxygen/html/ex16_8cpp_source.html">Example 16</a>: time-dependent nonlinear heat equation.</li>
  <li><a href="http://mfem.github.io/doxygen/html/ex17_8cpp_source.html">Example 17</a>: Discontinuous Galerkin (DG) for linear elasticity.</li>
  <li><a href="http://mfem.github.io/doxygen/html/ex18_8cpp_source.html">Example 18</a>: Discontinuous Galerkin (DG) for the Euler equations.</li>
  <li><a href="http://mfem.github.io/doxygen/html/ex19_8cpp_source.html">Example 19</a>: incompressible nonlinear elasticity.</li>
</ul>

<p>Most of the examples have a serial and a parallel version, illustrating the ease of transition and the minimal code changes between the two.</p>

<p>Many of the examples also have modifications that take advantage of optional third-party libraries such as <a href="http://mfem.github.io/doxygen/html/petsc_8hpp.html">PETSc</a>, <a href="http://mfem.github.io/doxygen/html/sundials_8hpp.html">SUNDIALS</a> and <a href="http://mfem.github.io/doxygen/html/pumi_8hpp.html">PUMI</a>.</p>

<p>Beyond the examples, a number of miniapps are available that are more representative of the advanced usage of the library in physics/application codes. Some of the included miniapps are:</p>

<ul>
  <li><a href="http://mfem.github.io/doxygen/html/volta_8cpp_source.html">Volta</a>: simple electrostatics simulation code.</li>
  <li><a href="http://mfem.github.io/doxygen/html/tesla_8cpp_source.html">Tesla</a>: simple magnetostatics simulation code.</li>
  <li><a href="http://mfem.github.io/doxygen/html/maxwell_8cpp_source.html">Maxwell</a>: transient electromagnetics simulation code.</li>
  <li><a href="http://mfem.github.io/doxygen/html/joule_8cpp_source.html">Joule</a>: transient magnetics and Joule heating miniapp.</li>
  <li><a href="http://mfem.github.io/doxygen/html/shaper_8cpp.html">Shaper</a>: resolve material interfaces by mesh refinement. ⭐</li>
  <li><a href="http://mfem.github.io/doxygen/html/mesh-explorer_8cpp_source.html">Mesh Explorer</a>: visualize and manipulate meshes.</li>
  <li><a href="http://mfem.github.io/doxygen/html/mesh-optimizer_8cpp_source.html">Mesh Optimizer</a>: optimize high-order meshes.</li>
</ul>

<p>In addition, the sources for several external benchmark/proxy-apps build on top of MFEM are available:</p>

<ul>
  <li><a href="https://github.com/CEED/Laghos">Laghos</a>: high-order Lagrangian hydrodynamics miniapp. ⭐</li>
  <li><a href="https://codesign.llnl.gov/mulard.php">Mulard</a>: multigroup thermal radiation diffusion mini application.</li>
</ul>

<h5 id="bonus-2-create-your-own-simple-simulation">(Bonus #2) Create Your Own Simple Simulation</h5>

<p>Modify the miniapps and example codes, either in your local copy on Cooley, or on your laptop to
create a simple simulation of your own. In both cases you should be able to edit the source code
and rebuild the binary simply with <code class="highlighter-rouge">make</code>.</p>

<p>For example, you can solve a steady-state <a href="../hand_coded_heat/">heat conduction</a> problem in 2D
and 3D using the <code class="highlighter-rouge">shaper</code> miniapp (modified for the cable shape) to define the mesh and <code class="highlighter-rouge">ex1</code>
or <code class="highlighter-rouge">ex1p</code> to solve it (modified to include separate coefficients for air and cable).</p>

<p><em>We want to see your creativity – the best simulations will enter for a chance to be
featured on MFEM’s <a href="http://mfem.org/gallery/">gallery</a> page!</em></p>

<p>Please consult the MFEM <a href="http://mfem.github.io/doxygen/html/index.html">code documentation</a> and
don’t hesitate to ask if you have any implementation questions.</p>

<h4 id="to-get-credit--points">To Get Credit / Points</h4>

<p>To get points, please submit screenshots, simulation images and any additional material you have
generated via <em><a href="https://goo.gl/forms/B7UFpBvEOJbC58oJ2">Show Your Work</a></em>
using the hands-on activity name <code class="highlighter-rouge">MFEM_HandsOn</code>.</p>


                        
                        <p><a href='../../lessons'>Back to all ATPESC 2018 Lessons</a></p>
                        

		</article>
	</div><!-- /.medium-12.columns -->
</div><!-- /.row -->




	
	    <div id="up-to-top" class="row">
      <div class="small-12 columns" style="text-align: right;">
        <a class="iconfont" href="#top-of-page">&#xf108;</a>
      </div><!-- /.small-12.columns -->
    </div><!-- /.row -->


    <footer id="footer-content" class="bg-grau">
      <div id="footer">
        <div class="row">
          <div class="medium-6 large-5 columns">
            <h5 class="shadow-black">About This Site</h5>

            <p class="shadow-black">
              <a href="https://software-carpentry.org">Software Carpentry</a> Style Lessons for Numerical Libraries
              <a href="http://localhost:4000/info/">More ›</a>
              Created by <a href="https://github.com/markcmiller86">Mark C Miller</a> with <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> based on <a href="http://phlow.github.io/feeling-responsive/">Feeling Responsive</a>.</p>
            </p>
          </div><!-- /.large-6.columns -->

          <div class="small-6 medium-3 large-3 columns">
            <ul class="inline-list social-icons">
            
              <li><a href="https://fastmath-scidac.llnl.gov" target="_blank" class="icon-home" title="FASTMath"></a></li>
            
              <li><a href="https://www.youtube.com/playlist?list=PLGj2a3KTwhRZKjI7pRFxQDBORsswJAdJt" target="_blank" class="icon-youtube" title="ATPESC-2017 Numerical Libaries"></a></li>
            
              <li><a href="https://www.youtube.com/channel/UCEkJLPAMOUsjC_RXGFcVq-A/videos" target="_blank" class="icon-youtube" title="IDEAS on YouTube"></a></li>
            
              <li><a href="http://twitter.com/exascaleproject" target="_blank" class="icon-twitter" title="Exascale Project on Twitter"></a></li>
            
            </ul>

                        <a class="button left r15 tiny radius" href="https://github.com/xsdk-project/ATPESC2018HandsOnLessons/edit/gh-pages/_lessons/mfem_convergence/lesson.md">Edit This Page On GitHub</a>



          </div><!-- /.large-3.columns -->
        </div><!-- /.row -->

      </div><!-- /#footer -->

    </footer>

	

	


<script src="http://localhost:4000/assets/js/javascript.min.js"></script>



<script>
    $("#masthead").backstretch("http://localhost:4000/images/WSC_top4.jpg", {fade: 700});
    $("#masthead-with-text").backstretch("http://localhost:4000/images/WSC_top4.jpg", {fade: 700});
</script>












</body>
</html>

