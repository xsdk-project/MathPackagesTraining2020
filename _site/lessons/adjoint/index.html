<!doctype html>
<html class="no-js" lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Using adjoint for PDE-constrained optimization</title>

    <link rel="stylesheet" type="text/css" href="http://localhost:4000/assets/css/styles_feeling_responsive.css">

  

	<script src="http://localhost:4000/assets/js/modernizr.min.js"></script>

	<script src="https://ajax.googleapis.com/ajax/libs/webfont/1.5.18/webfont.js"></script>
	<script>
		WebFont.load({
			google: {
				families: [ 'Lato:400,700,400italic:latin', 'Volkhov::latin' ]
			}
		});
	</script>

	<noscript>
		<link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic%7CVolkhov' rel='stylesheet' type='text/css'>
	</noscript>


	<!-- Search Engine Optimization -->
	<meta name="description" content="At a Glance



  
    
      Questions
      Objectives
      Key Points
    
    
      How can gradients be computed for simulations?
      Know PETSc/TAO’s capability for adjoint and optimization
      Adjoint enables dynamic constrained optimization
    
    
      How difficult is it to use the adjoint method?
      Understand ingredients needed  for adjoint calculation
      Jacobian is imperative
    
    
       
      Understand the concern of checkpointing
      Performance may depend on checkpointing at large scale
    
  


Note: To begin this lesson…
cd HandsOnLessons/adjoint


An Inverse Initial Value Problem

This code demonstrates how to solve an inverse initial value problem for a system of time-dependent PDEs on a 2D rectangular grid.
The goal is to determine an optimal initial condition that can minimizes the difference between the simulated result and the reference solution.
We will use this example to illustrate the performance considerations for realistic large-scale applications. In particular, we will show how to play with checkpointing and how to profile/tune the performance.

Compile the code
The example ex5opt_ic.c can be compiled with

make ex5opt_ic

To clean the example, do
make clean


ATPESC participants do not need to compile code because binaries are available in the ATPESC project folder on Cooley.

Command line options
You can determine the command line options available for this particular example by doing
./ex5opt_ic -help

and show the options related to TAO only by doing
./ex5opt_ic -help | grep tao


Problem being solved

The underlying PDE models reaction and diffusion of two chemical species that can produce a variety of patterns. It is widely used to describe pattern-formation phenomena in biological, chemical and physical systems. The concentrations of the two species are calculated according to the equation



The spatial pattern for the time interval [0,200] seconds is shown in the following figure.


  
    
      Figure 1
    
  
  
    
      
    
  


Given the pattern (observation) at the final time of the simulation, we want to determine the initial pattern that can minimize the difference between the simulated result and the observation.



Run 1: Monitor solution graphically

mpiexec -n 4 ./ex5opt_ic -forwardonly -ts_type rk -ts_rk_type 3 -ts_max_steps 20 -ts_monitor -ts_monitor_draw_solution



  -forwardonly perform the forward simulation without doing optimization
  -ts_type rk -ts_rk_type 3 changes the time stepping algorithm to a 3rd-order Runge-Kutta method
  -ts_monitor_draw_solution monitors the progress for the solution at each time step
  Add -draw_pause -2 if you want to pause at the end of simulation to see the plot


Run 2: Optimal checkpointing schedule
By default, the checkpoints are stored in binary files on disk. Of course, this may not be a good choice for large-scale applications running on high-performance machines where I/O cost is significant. We can make the solver use RAM for checkpointing and specify the maximum allowable checkpoints so that an optimal adjoint checkpointing schedule that minimizes the number of recomputations will be generated.

mpiexec -n 4 ./ex5opt_ic -ts_type rk -ts_rk_type 3 -ts_adapt_type none \
                     -ts_max_steps 10 -ts_monitor -ts_adjoint_monitor \
                     -ts_trajectory_type memory -ts_trajectory_max_cps_ram 3 \
                     -ts_trajectory_monitor -ts_trajectory_view -tao_max_it 1


  -tao_max_it 1 forces the optimization to stop after one iteration so that we can focus on the output related to the adjoint checkpointing.
The output corresponds to the schedule depicted by the following diagram:




Questions


  
  
  What will happen if we add the option -ts_trajectory_max_cps_disk 2 to specify there are two available slots for disk checkpoints?

  
    
    
      
          Looking at the output, we will find that the new schedule uses both RAM and disk for checkpointing and takes two less recomputations.

      
    
  


Run 3: Monitor the optimization progress

mpiexec -n 4 ./ex5opt_ic -ts_type rk -ts_rk_type 3 -ts_adapt_type none -ts_max_steps 5 -ts_trajectory_type memory -ts_trajectory_solution_only 0 -tao_monitor -tao_view
  0 TAO,  Function value: 8.48202,  Residual: 7.02449
  1 TAO,  Function value: 1.72589,  Residual: 2.46827
  2 TAO,  Function value: 0.556599,  Residual: 1.75419
  3 TAO,  Function value: 0.181113,  Residual: 0.698038
  4 TAO,  Function value: 0.0919628,  Residual: 0.390951
  5 TAO,  Function value: 0.0330733,  Residual: 0.276822
  6 TAO,  Function value: 0.0137442,  Residual: 0.205942
  7 TAO,  Function value: 0.0032463,  Residual: 0.0925536
  8 TAO,  Function value: 0.000876358,  Residual: 0.0469696
  9 TAO,  Function value: 0.000172022,  Residual: 0.0205954
 10 TAO,  Function value: 2.32065e-05,  Residual: 0.00808249
 11 TAO,  Function value: 1.00524e-05,  Residual: 0.00695292
 12 TAO,  Function value: 2.19094e-06,  Residual: 0.00192488
 13 TAO,  Function value: 9.37506e-07,  Residual: 0.00115926
 14 TAO,  Function value: 2.79883e-07,  Residual: 0.000907609
 15 TAO,  Function value: 7.22e-08,  Residual: 0.000346602
 16 TAO,  Function value: 3.51499e-08,  Residual: 0.000184429
 17 TAO,  Function value: 1.48741e-08,  Residual: 0.000117587
 18 TAO,  Function value: 7.83221e-09,  Residual: 9.19265e-05
 19 TAO,  Function value: 2.14226e-09,  Residual: 4.54118e-05
 20 TAO,  Function value: 8.99022e-10,  Residual: 2.91421e-05
 21 TAO,  Function value: 3.28239e-10,  Residual: 2.06652e-05
 22 TAO,  Function value: 1.85795e-10,  Residual: 2.71364e-05
 23 TAO,  Function value: 1.14498e-10,  Residual: 2.32933e-05
 24 TAO,  Function value: 8.12369e-11,  Residual: 2.22391e-05
 25 TAO,  Function value: 1.87747e-11,  Residual: 7.85018e-06
 26 TAO,  Function value: 7.29614e-12,  Residual: 5.02828e-06
 27 TAO,  Function value: 1.72522e-12,  Residual: 1.07136e-06
 28 TAO,  Function value: 1.0259e-12,  Residual: 7.63383e-07
 29 TAO,  Function value: 1.72785e-13,  Residual: 3.91911e-07
 30 TAO,  Function value: 1.0509e-13,  Residual: 2.75909e-07
 31 TAO,  Function value: 4.02491e-14,  Residual: 1.7222e-07
 32 TAO,  Function value: 1.5385e-14,  Residual: 1.21345e-07
 33 TAO,  Function value: 3.20145e-15,  Residual: 7.81137e-08
 34 TAO,  Function value: 1.66953e-15,  Residual: 5.25802e-08
 35 TAO,  Function value: 3.39432e-16,  Residual: 3.16327e-08
 36 TAO,  Function value: 9.68078e-17,  Residual: 1.15783e-08
 37 TAO,  Function value: 8.23443e-17,  Residual: 1.68247e-08
 38 TAO,  Function value: 1.53356e-17,  Residual: 7.63537e-09
Tao Object: 4 MPI processes
  type: blmvm
  Gradient steps: 0
  Mat Object: (tao_blmvm_) 4 MPI processes
    type: lmvmbfgs
    rows=8192, cols=8192
      Scale type: diagonal
      Scale history: 1
      Scale params: alpha=1., beta=0.5, rho=1.
      Convex factors: phi=0., theta=0.125
      Max. storage: 5
      Used storage: 5
      Number of updates: 37
      Number of rejects: 0
      Number of resets: 1
  TaoLineSearch Object: 4 MPI processes
    type: more-thuente
    maximum function evaluations=30
    tolerances: ftol=0.0001, rtol=1e-10, gtol=0.9
    total number of function evaluations=0
    total number of gradient evaluations=0
    total number of function/gradient evaluations=1
    using variable bounds
    Termination reason: 1
  Active Set subset type: subvec
  convergence tolerances: gatol=1e-08,   steptol=0.,   gttol=0.
  Residual in Function/Gradient:=7.63537e-09
  Objective value=1.53356e-17
  total number of iterations=38,                          (max: 2000)
  total number of function/gradient evaluations=41,      (max: 4000)
  Solution converged:    ||g(X)|| &amp;lt;= gatol


  -tao_draw_solution can visualize the solution at each optimization iteration


Questions


  
  
  Examine the source code and find the user-provided functions for TAO, TS, and TSAdjoint respectively.

  
    
    
      
          Essential functions we have provided are FormFunctionGradient for TAO, TSIFunction and TSIJacobian for TS,  RHSJacobianP for TSAdjoint. Because of the integral in the objective function, extra functions including CostIntegrand, DRDYFunction and DRDPFunction are given to TSAdjoint.

      
    
  


Run 4: Implicit time integration method
Now we switch to an implicit method (Crank-Nicolson) using fixed stepsize, which is the default setting in the code. At each time step, a nonlinear system is solved by the PETSc nonlinear solver SNES.
mpiexec -n 12 ./ex5opt_ic -ts_max_steps 5 -log_view -tao_monitor


  -snes_monitor can show the progress of SNES
  -ts_monitor can show the progress of TS
  -log_view prints a summary of the logging


A snippet of the summary:
...
Phase summary info:
   Count: number of times phase was executed
   Time and Flop: Max - maximum over all processors
                   Ratio - ratio of maximum to minimum over all processors
   Mess: number of messages sent
   Avg. len: average message length (bytes)
   Reduct: number of global reductions
   Global: entire computation
   Stage: stages of a computation. Set stages with PetscLogStagePush() and PetscLogStagePop().
      %T - percent time in this phase         %F - percent flop in this phase
      %M - percent messages in this phase     %L - percent message lengths in this phase
      %R - percent reductions in this phase
   Total Mflop/s: 10e-6 * (sum of flop over all processors)/(max time over all processors)
------------------------------------------------------------------------------------------------------------------------
Event                Count      Time (sec)     Flop                             --- Global ---  --- Stage ---   Total
                   Max Ratio  Max     Ratio   Max  Ratio  Mess   Avg len Reduct  %T %F %M %L %R  %T %F %M %L %R Mflop/s
------------------------------------------------------------------------------------------------------------------------

--- Event Stage 0: Main Stage

VecDot              1130 1.0 3.9795e-01 1.4 1.59e+06 1.0 0.0e+00 0.0e+00 1.1e+03  4  1  0  0  8   4  1  0  0  8    46
VecMDot             1919 1.0 5.9272e-01 2.0 5.40e+06 1.0 0.0e+00 0.0e+00 1.9e+03  5  4  0  0 14   5  4  0  0 14   106
VecNorm             3678 1.0 8.1644e-01 1.3 5.18e+06 1.0 0.0e+00 0.0e+00 3.7e+03  9  4  0  0 27   9  4  0  0 27    74
...


Questions


  
  
  Where is the majority of CPU time spent?

  
    
    
      
          Of course answer may vary depending on the settings such as number of procs, problem size, and solver options. Typically most of the time should be spent on VecMDot or MatMult

      
    
  



  
  
  How can we improve performance?

  
    
    
      
          
  Use memory instead of disk for checkpointing(-ts_trajectory_type memory -ts_trajectory_solution_only 0); 2. Tune the time stepping solver, nonlinear solver, linear solver, preconditioner and so forth.


      
    
  


Run 5: Scale up the problem
We use explicit Runge-Kutta methods for time integration, and increase the grid resolution to 512 X 512.
mpiexec -n 12 ./ex5opt_ic -ts_type rk -ts_rk_type 3 -ts_adapt_type none -ts_max_steps 5 -ts_trajectory_type memory -ts_trajectory_solution_only 0 -tao_monitor -da_grid_x 512 -da_grid_y 512


Questions


  
  
  Does the optimization converge? If not, can you fix it?

  
    
    
      
          No. The PDE solution blows up. As we decrease the grid spacing, the stepsize  should be reduced according to CFL condition. For example, adding -ts_dt 0.1 should work.

      
    
  


Further information
Because this example uses DMDA, Jacobian can be efficiently approximated using finite difference with coloring. You can use the option -snes_fd_color to enable this feature.

Out-Brief

We have used PETSc to demonstrate the adjoint capability as an enabling technology for dynamic-constrained optimization. In particular, we investigated an inverse initial value porblem built on a time-dependent reaction-diffusion PDE.

We have shown the basic usage of the adjoint solver as well as functionalities that can facilitate rapid development, diagnosis and performance profiling.

Further Reading

PETSc Documentation



 



Back to all HandsOnLessons">
	<meta name="google-site-verification" content="Vk0IOJ2jwG_qEoG7fuEXYqv0m2rLa8P778Fi_GrsgEQ">
	<meta name="msvalidate.01" content="0FB4C028ABCF07C908C54386ABD2D97F" >
	
	<link rel="author" href="https://plus.google.com/u/0/118311555303973066167">
	
	
	<link rel="canonical" href="http://localhost:4000/lessons/adjoint/">


	<!-- Facebook Open Graph -->
	<meta property="og:title" content="Using adjoint for PDE-constrained optimization">
	<meta property="og:description" content="At a Glance



  
    
      Questions
      Objectives
      Key Points
    
    
      How can gradients be computed for simulations?
      Know PETSc/TAO’s capability for adjoint and optimization
      Adjoint enables dynamic constrained optimization
    
    
      How difficult is it to use the adjoint method?
      Understand ingredients needed  for adjoint calculation
      Jacobian is imperative
    
    
       
      Understand the concern of checkpointing
      Performance may depend on checkpointing at large scale
    
  


Note: To begin this lesson…
cd HandsOnLessons/adjoint


An Inverse Initial Value Problem

This code demonstrates how to solve an inverse initial value problem for a system of time-dependent PDEs on a 2D rectangular grid.
The goal is to determine an optimal initial condition that can minimizes the difference between the simulated result and the reference solution.
We will use this example to illustrate the performance considerations for realistic large-scale applications. In particular, we will show how to play with checkpointing and how to profile/tune the performance.

Compile the code
The example ex5opt_ic.c can be compiled with

make ex5opt_ic

To clean the example, do
make clean


ATPESC participants do not need to compile code because binaries are available in the ATPESC project folder on Cooley.

Command line options
You can determine the command line options available for this particular example by doing
./ex5opt_ic -help

and show the options related to TAO only by doing
./ex5opt_ic -help | grep tao


Problem being solved

The underlying PDE models reaction and diffusion of two chemical species that can produce a variety of patterns. It is widely used to describe pattern-formation phenomena in biological, chemical and physical systems. The concentrations of the two species are calculated according to the equation



The spatial pattern for the time interval [0,200] seconds is shown in the following figure.


  
    
      Figure 1
    
  
  
    
      
    
  


Given the pattern (observation) at the final time of the simulation, we want to determine the initial pattern that can minimize the difference between the simulated result and the observation.



Run 1: Monitor solution graphically

mpiexec -n 4 ./ex5opt_ic -forwardonly -ts_type rk -ts_rk_type 3 -ts_max_steps 20 -ts_monitor -ts_monitor_draw_solution



  -forwardonly perform the forward simulation without doing optimization
  -ts_type rk -ts_rk_type 3 changes the time stepping algorithm to a 3rd-order Runge-Kutta method
  -ts_monitor_draw_solution monitors the progress for the solution at each time step
  Add -draw_pause -2 if you want to pause at the end of simulation to see the plot


Run 2: Optimal checkpointing schedule
By default, the checkpoints are stored in binary files on disk. Of course, this may not be a good choice for large-scale applications running on high-performance machines where I/O cost is significant. We can make the solver use RAM for checkpointing and specify the maximum allowable checkpoints so that an optimal adjoint checkpointing schedule that minimizes the number of recomputations will be generated.

mpiexec -n 4 ./ex5opt_ic -ts_type rk -ts_rk_type 3 -ts_adapt_type none \
                     -ts_max_steps 10 -ts_monitor -ts_adjoint_monitor \
                     -ts_trajectory_type memory -ts_trajectory_max_cps_ram 3 \
                     -ts_trajectory_monitor -ts_trajectory_view -tao_max_it 1


  -tao_max_it 1 forces the optimization to stop after one iteration so that we can focus on the output related to the adjoint checkpointing.
The output corresponds to the schedule depicted by the following diagram:




Questions


  
  
  What will happen if we add the option -ts_trajectory_max_cps_disk 2 to specify there are two available slots for disk checkpoints?

  
    
    
      
          Looking at the output, we will find that the new schedule uses both RAM and disk for checkpointing and takes two less recomputations.

      
    
  


Run 3: Monitor the optimization progress

mpiexec -n 4 ./ex5opt_ic -ts_type rk -ts_rk_type 3 -ts_adapt_type none -ts_max_steps 5 -ts_trajectory_type memory -ts_trajectory_solution_only 0 -tao_monitor -tao_view
  0 TAO,  Function value: 8.48202,  Residual: 7.02449
  1 TAO,  Function value: 1.72589,  Residual: 2.46827
  2 TAO,  Function value: 0.556599,  Residual: 1.75419
  3 TAO,  Function value: 0.181113,  Residual: 0.698038
  4 TAO,  Function value: 0.0919628,  Residual: 0.390951
  5 TAO,  Function value: 0.0330733,  Residual: 0.276822
  6 TAO,  Function value: 0.0137442,  Residual: 0.205942
  7 TAO,  Function value: 0.0032463,  Residual: 0.0925536
  8 TAO,  Function value: 0.000876358,  Residual: 0.0469696
  9 TAO,  Function value: 0.000172022,  Residual: 0.0205954
 10 TAO,  Function value: 2.32065e-05,  Residual: 0.00808249
 11 TAO,  Function value: 1.00524e-05,  Residual: 0.00695292
 12 TAO,  Function value: 2.19094e-06,  Residual: 0.00192488
 13 TAO,  Function value: 9.37506e-07,  Residual: 0.00115926
 14 TAO,  Function value: 2.79883e-07,  Residual: 0.000907609
 15 TAO,  Function value: 7.22e-08,  Residual: 0.000346602
 16 TAO,  Function value: 3.51499e-08,  Residual: 0.000184429
 17 TAO,  Function value: 1.48741e-08,  Residual: 0.000117587
 18 TAO,  Function value: 7.83221e-09,  Residual: 9.19265e-05
 19 TAO,  Function value: 2.14226e-09,  Residual: 4.54118e-05
 20 TAO,  Function value: 8.99022e-10,  Residual: 2.91421e-05
 21 TAO,  Function value: 3.28239e-10,  Residual: 2.06652e-05
 22 TAO,  Function value: 1.85795e-10,  Residual: 2.71364e-05
 23 TAO,  Function value: 1.14498e-10,  Residual: 2.32933e-05
 24 TAO,  Function value: 8.12369e-11,  Residual: 2.22391e-05
 25 TAO,  Function value: 1.87747e-11,  Residual: 7.85018e-06
 26 TAO,  Function value: 7.29614e-12,  Residual: 5.02828e-06
 27 TAO,  Function value: 1.72522e-12,  Residual: 1.07136e-06
 28 TAO,  Function value: 1.0259e-12,  Residual: 7.63383e-07
 29 TAO,  Function value: 1.72785e-13,  Residual: 3.91911e-07
 30 TAO,  Function value: 1.0509e-13,  Residual: 2.75909e-07
 31 TAO,  Function value: 4.02491e-14,  Residual: 1.7222e-07
 32 TAO,  Function value: 1.5385e-14,  Residual: 1.21345e-07
 33 TAO,  Function value: 3.20145e-15,  Residual: 7.81137e-08
 34 TAO,  Function value: 1.66953e-15,  Residual: 5.25802e-08
 35 TAO,  Function value: 3.39432e-16,  Residual: 3.16327e-08
 36 TAO,  Function value: 9.68078e-17,  Residual: 1.15783e-08
 37 TAO,  Function value: 8.23443e-17,  Residual: 1.68247e-08
 38 TAO,  Function value: 1.53356e-17,  Residual: 7.63537e-09
Tao Object: 4 MPI processes
  type: blmvm
  Gradient steps: 0
  Mat Object: (tao_blmvm_) 4 MPI processes
    type: lmvmbfgs
    rows=8192, cols=8192
      Scale type: diagonal
      Scale history: 1
      Scale params: alpha=1., beta=0.5, rho=1.
      Convex factors: phi=0., theta=0.125
      Max. storage: 5
      Used storage: 5
      Number of updates: 37
      Number of rejects: 0
      Number of resets: 1
  TaoLineSearch Object: 4 MPI processes
    type: more-thuente
    maximum function evaluations=30
    tolerances: ftol=0.0001, rtol=1e-10, gtol=0.9
    total number of function evaluations=0
    total number of gradient evaluations=0
    total number of function/gradient evaluations=1
    using variable bounds
    Termination reason: 1
  Active Set subset type: subvec
  convergence tolerances: gatol=1e-08,   steptol=0.,   gttol=0.
  Residual in Function/Gradient:=7.63537e-09
  Objective value=1.53356e-17
  total number of iterations=38,                          (max: 2000)
  total number of function/gradient evaluations=41,      (max: 4000)
  Solution converged:    ||g(X)|| &amp;lt;= gatol


  -tao_draw_solution can visualize the solution at each optimization iteration


Questions


  
  
  Examine the source code and find the user-provided functions for TAO, TS, and TSAdjoint respectively.

  
    
    
      
          Essential functions we have provided are FormFunctionGradient for TAO, TSIFunction and TSIJacobian for TS,  RHSJacobianP for TSAdjoint. Because of the integral in the objective function, extra functions including CostIntegrand, DRDYFunction and DRDPFunction are given to TSAdjoint.

      
    
  


Run 4: Implicit time integration method
Now we switch to an implicit method (Crank-Nicolson) using fixed stepsize, which is the default setting in the code. At each time step, a nonlinear system is solved by the PETSc nonlinear solver SNES.
mpiexec -n 12 ./ex5opt_ic -ts_max_steps 5 -log_view -tao_monitor


  -snes_monitor can show the progress of SNES
  -ts_monitor can show the progress of TS
  -log_view prints a summary of the logging


A snippet of the summary:
...
Phase summary info:
   Count: number of times phase was executed
   Time and Flop: Max - maximum over all processors
                   Ratio - ratio of maximum to minimum over all processors
   Mess: number of messages sent
   Avg. len: average message length (bytes)
   Reduct: number of global reductions
   Global: entire computation
   Stage: stages of a computation. Set stages with PetscLogStagePush() and PetscLogStagePop().
      %T - percent time in this phase         %F - percent flop in this phase
      %M - percent messages in this phase     %L - percent message lengths in this phase
      %R - percent reductions in this phase
   Total Mflop/s: 10e-6 * (sum of flop over all processors)/(max time over all processors)
------------------------------------------------------------------------------------------------------------------------
Event                Count      Time (sec)     Flop                             --- Global ---  --- Stage ---   Total
                   Max Ratio  Max     Ratio   Max  Ratio  Mess   Avg len Reduct  %T %F %M %L %R  %T %F %M %L %R Mflop/s
------------------------------------------------------------------------------------------------------------------------

--- Event Stage 0: Main Stage

VecDot              1130 1.0 3.9795e-01 1.4 1.59e+06 1.0 0.0e+00 0.0e+00 1.1e+03  4  1  0  0  8   4  1  0  0  8    46
VecMDot             1919 1.0 5.9272e-01 2.0 5.40e+06 1.0 0.0e+00 0.0e+00 1.9e+03  5  4  0  0 14   5  4  0  0 14   106
VecNorm             3678 1.0 8.1644e-01 1.3 5.18e+06 1.0 0.0e+00 0.0e+00 3.7e+03  9  4  0  0 27   9  4  0  0 27    74
...


Questions


  
  
  Where is the majority of CPU time spent?

  
    
    
      
          Of course answer may vary depending on the settings such as number of procs, problem size, and solver options. Typically most of the time should be spent on VecMDot or MatMult

      
    
  



  
  
  How can we improve performance?

  
    
    
      
          
  Use memory instead of disk for checkpointing(-ts_trajectory_type memory -ts_trajectory_solution_only 0); 2. Tune the time stepping solver, nonlinear solver, linear solver, preconditioner and so forth.


      
    
  


Run 5: Scale up the problem
We use explicit Runge-Kutta methods for time integration, and increase the grid resolution to 512 X 512.
mpiexec -n 12 ./ex5opt_ic -ts_type rk -ts_rk_type 3 -ts_adapt_type none -ts_max_steps 5 -ts_trajectory_type memory -ts_trajectory_solution_only 0 -tao_monitor -da_grid_x 512 -da_grid_y 512


Questions


  
  
  Does the optimization converge? If not, can you fix it?

  
    
    
      
          No. The PDE solution blows up. As we decrease the grid spacing, the stepsize  should be reduced according to CFL condition. For example, adding -ts_dt 0.1 should work.

      
    
  


Further information
Because this example uses DMDA, Jacobian can be efficiently approximated using finite difference with coloring. You can use the option -snes_fd_color to enable this feature.

Out-Brief

We have used PETSc to demonstrate the adjoint capability as an enabling technology for dynamic-constrained optimization. In particular, we investigated an inverse initial value porblem built on a time-dependent reaction-diffusion PDE.

We have shown the basic usage of the adjoint solver as well as functionalities that can facilitate rapid development, diagnosis and performance profiling.

Further Reading

PETSc Documentation



 



Back to all HandsOnLessons">
	<meta property="og:url" content="http://localhost:4000/lessons/adjoint/">
	<meta property="og:locale" content="en_EN">
	<meta property="og:type" content="website">
	<meta property="og:site_name" content="ATPESC 2018 Math Library Hands On Exercises">
	
	<meta property="article:author" content="https://www.facebook.com/phlow.media">


	
	<!-- Twitter -->
	<meta name="twitter:card" content="summary">
	<meta name="twitter:site" content="phlow">
	<meta name="twitter:creator" content="phlow">
	<meta name="twitter:title" content="Using adjoint for PDE-constrained optimization">
	<meta name="twitter:description" content="At a Glance



  
    
      Questions
      Objectives
      Key Points
    
    
      How can gradients be computed for simulations?
      Know PETSc/TAO’s capability for adjoint and optimization
      Adjoint enables dynamic constrained optimization
    
    
      How difficult is it to use the adjoint method?
      Understand ingredients needed  for adjoint calculation
      Jacobian is imperative
    
    
       
      Understand the concern of checkpointing
      Performance may depend on checkpointing at large scale
    
  


Note: To begin this lesson…
cd HandsOnLessons/adjoint


An Inverse Initial Value Problem

This code demonstrates how to solve an inverse initial value problem for a system of time-dependent PDEs on a 2D rectangular grid.
The goal is to determine an optimal initial condition that can minimizes the difference between the simulated result and the reference solution.
We will use this example to illustrate the performance considerations for realistic large-scale applications. In particular, we will show how to play with checkpointing and how to profile/tune the performance.

Compile the code
The example ex5opt_ic.c can be compiled with

make ex5opt_ic

To clean the example, do
make clean


ATPESC participants do not need to compile code because binaries are available in the ATPESC project folder on Cooley.

Command line options
You can determine the command line options available for this particular example by doing
./ex5opt_ic -help

and show the options related to TAO only by doing
./ex5opt_ic -help | grep tao


Problem being solved

The underlying PDE models reaction and diffusion of two chemical species that can produce a variety of patterns. It is widely used to describe pattern-formation phenomena in biological, chemical and physical systems. The concentrations of the two species are calculated according to the equation



The spatial pattern for the time interval [0,200] seconds is shown in the following figure.


  
    
      Figure 1
    
  
  
    
      
    
  


Given the pattern (observation) at the final time of the simulation, we want to determine the initial pattern that can minimize the difference between the simulated result and the observation.



Run 1: Monitor solution graphically

mpiexec -n 4 ./ex5opt_ic -forwardonly -ts_type rk -ts_rk_type 3 -ts_max_steps 20 -ts_monitor -ts_monitor_draw_solution



  -forwardonly perform the forward simulation without doing optimization
  -ts_type rk -ts_rk_type 3 changes the time stepping algorithm to a 3rd-order Runge-Kutta method
  -ts_monitor_draw_solution monitors the progress for the solution at each time step
  Add -draw_pause -2 if you want to pause at the end of simulation to see the plot


Run 2: Optimal checkpointing schedule
By default, the checkpoints are stored in binary files on disk. Of course, this may not be a good choice for large-scale applications running on high-performance machines where I/O cost is significant. We can make the solver use RAM for checkpointing and specify the maximum allowable checkpoints so that an optimal adjoint checkpointing schedule that minimizes the number of recomputations will be generated.

mpiexec -n 4 ./ex5opt_ic -ts_type rk -ts_rk_type 3 -ts_adapt_type none \
                     -ts_max_steps 10 -ts_monitor -ts_adjoint_monitor \
                     -ts_trajectory_type memory -ts_trajectory_max_cps_ram 3 \
                     -ts_trajectory_monitor -ts_trajectory_view -tao_max_it 1


  -tao_max_it 1 forces the optimization to stop after one iteration so that we can focus on the output related to the adjoint checkpointing.
The output corresponds to the schedule depicted by the following diagram:




Questions


  
  
  What will happen if we add the option -ts_trajectory_max_cps_disk 2 to specify there are two available slots for disk checkpoints?

  
    
    
      
          Looking at the output, we will find that the new schedule uses both RAM and disk for checkpointing and takes two less recomputations.

      
    
  


Run 3: Monitor the optimization progress

mpiexec -n 4 ./ex5opt_ic -ts_type rk -ts_rk_type 3 -ts_adapt_type none -ts_max_steps 5 -ts_trajectory_type memory -ts_trajectory_solution_only 0 -tao_monitor -tao_view
  0 TAO,  Function value: 8.48202,  Residual: 7.02449
  1 TAO,  Function value: 1.72589,  Residual: 2.46827
  2 TAO,  Function value: 0.556599,  Residual: 1.75419
  3 TAO,  Function value: 0.181113,  Residual: 0.698038
  4 TAO,  Function value: 0.0919628,  Residual: 0.390951
  5 TAO,  Function value: 0.0330733,  Residual: 0.276822
  6 TAO,  Function value: 0.0137442,  Residual: 0.205942
  7 TAO,  Function value: 0.0032463,  Residual: 0.0925536
  8 TAO,  Function value: 0.000876358,  Residual: 0.0469696
  9 TAO,  Function value: 0.000172022,  Residual: 0.0205954
 10 TAO,  Function value: 2.32065e-05,  Residual: 0.00808249
 11 TAO,  Function value: 1.00524e-05,  Residual: 0.00695292
 12 TAO,  Function value: 2.19094e-06,  Residual: 0.00192488
 13 TAO,  Function value: 9.37506e-07,  Residual: 0.00115926
 14 TAO,  Function value: 2.79883e-07,  Residual: 0.000907609
 15 TAO,  Function value: 7.22e-08,  Residual: 0.000346602
 16 TAO,  Function value: 3.51499e-08,  Residual: 0.000184429
 17 TAO,  Function value: 1.48741e-08,  Residual: 0.000117587
 18 TAO,  Function value: 7.83221e-09,  Residual: 9.19265e-05
 19 TAO,  Function value: 2.14226e-09,  Residual: 4.54118e-05
 20 TAO,  Function value: 8.99022e-10,  Residual: 2.91421e-05
 21 TAO,  Function value: 3.28239e-10,  Residual: 2.06652e-05
 22 TAO,  Function value: 1.85795e-10,  Residual: 2.71364e-05
 23 TAO,  Function value: 1.14498e-10,  Residual: 2.32933e-05
 24 TAO,  Function value: 8.12369e-11,  Residual: 2.22391e-05
 25 TAO,  Function value: 1.87747e-11,  Residual: 7.85018e-06
 26 TAO,  Function value: 7.29614e-12,  Residual: 5.02828e-06
 27 TAO,  Function value: 1.72522e-12,  Residual: 1.07136e-06
 28 TAO,  Function value: 1.0259e-12,  Residual: 7.63383e-07
 29 TAO,  Function value: 1.72785e-13,  Residual: 3.91911e-07
 30 TAO,  Function value: 1.0509e-13,  Residual: 2.75909e-07
 31 TAO,  Function value: 4.02491e-14,  Residual: 1.7222e-07
 32 TAO,  Function value: 1.5385e-14,  Residual: 1.21345e-07
 33 TAO,  Function value: 3.20145e-15,  Residual: 7.81137e-08
 34 TAO,  Function value: 1.66953e-15,  Residual: 5.25802e-08
 35 TAO,  Function value: 3.39432e-16,  Residual: 3.16327e-08
 36 TAO,  Function value: 9.68078e-17,  Residual: 1.15783e-08
 37 TAO,  Function value: 8.23443e-17,  Residual: 1.68247e-08
 38 TAO,  Function value: 1.53356e-17,  Residual: 7.63537e-09
Tao Object: 4 MPI processes
  type: blmvm
  Gradient steps: 0
  Mat Object: (tao_blmvm_) 4 MPI processes
    type: lmvmbfgs
    rows=8192, cols=8192
      Scale type: diagonal
      Scale history: 1
      Scale params: alpha=1., beta=0.5, rho=1.
      Convex factors: phi=0., theta=0.125
      Max. storage: 5
      Used storage: 5
      Number of updates: 37
      Number of rejects: 0
      Number of resets: 1
  TaoLineSearch Object: 4 MPI processes
    type: more-thuente
    maximum function evaluations=30
    tolerances: ftol=0.0001, rtol=1e-10, gtol=0.9
    total number of function evaluations=0
    total number of gradient evaluations=0
    total number of function/gradient evaluations=1
    using variable bounds
    Termination reason: 1
  Active Set subset type: subvec
  convergence tolerances: gatol=1e-08,   steptol=0.,   gttol=0.
  Residual in Function/Gradient:=7.63537e-09
  Objective value=1.53356e-17
  total number of iterations=38,                          (max: 2000)
  total number of function/gradient evaluations=41,      (max: 4000)
  Solution converged:    ||g(X)|| &amp;lt;= gatol


  -tao_draw_solution can visualize the solution at each optimization iteration


Questions


  
  
  Examine the source code and find the user-provided functions for TAO, TS, and TSAdjoint respectively.

  
    
    
      
          Essential functions we have provided are FormFunctionGradient for TAO, TSIFunction and TSIJacobian for TS,  RHSJacobianP for TSAdjoint. Because of the integral in the objective function, extra functions including CostIntegrand, DRDYFunction and DRDPFunction are given to TSAdjoint.

      
    
  


Run 4: Implicit time integration method
Now we switch to an implicit method (Crank-Nicolson) using fixed stepsize, which is the default setting in the code. At each time step, a nonlinear system is solved by the PETSc nonlinear solver SNES.
mpiexec -n 12 ./ex5opt_ic -ts_max_steps 5 -log_view -tao_monitor


  -snes_monitor can show the progress of SNES
  -ts_monitor can show the progress of TS
  -log_view prints a summary of the logging


A snippet of the summary:
...
Phase summary info:
   Count: number of times phase was executed
   Time and Flop: Max - maximum over all processors
                   Ratio - ratio of maximum to minimum over all processors
   Mess: number of messages sent
   Avg. len: average message length (bytes)
   Reduct: number of global reductions
   Global: entire computation
   Stage: stages of a computation. Set stages with PetscLogStagePush() and PetscLogStagePop().
      %T - percent time in this phase         %F - percent flop in this phase
      %M - percent messages in this phase     %L - percent message lengths in this phase
      %R - percent reductions in this phase
   Total Mflop/s: 10e-6 * (sum of flop over all processors)/(max time over all processors)
------------------------------------------------------------------------------------------------------------------------
Event                Count      Time (sec)     Flop                             --- Global ---  --- Stage ---   Total
                   Max Ratio  Max     Ratio   Max  Ratio  Mess   Avg len Reduct  %T %F %M %L %R  %T %F %M %L %R Mflop/s
------------------------------------------------------------------------------------------------------------------------

--- Event Stage 0: Main Stage

VecDot              1130 1.0 3.9795e-01 1.4 1.59e+06 1.0 0.0e+00 0.0e+00 1.1e+03  4  1  0  0  8   4  1  0  0  8    46
VecMDot             1919 1.0 5.9272e-01 2.0 5.40e+06 1.0 0.0e+00 0.0e+00 1.9e+03  5  4  0  0 14   5  4  0  0 14   106
VecNorm             3678 1.0 8.1644e-01 1.3 5.18e+06 1.0 0.0e+00 0.0e+00 3.7e+03  9  4  0  0 27   9  4  0  0 27    74
...


Questions


  
  
  Where is the majority of CPU time spent?

  
    
    
      
          Of course answer may vary depending on the settings such as number of procs, problem size, and solver options. Typically most of the time should be spent on VecMDot or MatMult

      
    
  



  
  
  How can we improve performance?

  
    
    
      
          
  Use memory instead of disk for checkpointing(-ts_trajectory_type memory -ts_trajectory_solution_only 0); 2. Tune the time stepping solver, nonlinear solver, linear solver, preconditioner and so forth.


      
    
  


Run 5: Scale up the problem
We use explicit Runge-Kutta methods for time integration, and increase the grid resolution to 512 X 512.
mpiexec -n 12 ./ex5opt_ic -ts_type rk -ts_rk_type 3 -ts_adapt_type none -ts_max_steps 5 -ts_trajectory_type memory -ts_trajectory_solution_only 0 -tao_monitor -da_grid_x 512 -da_grid_y 512


Questions


  
  
  Does the optimization converge? If not, can you fix it?

  
    
    
      
          No. The PDE solution blows up. As we decrease the grid spacing, the stepsize  should be reduced according to CFL condition. For example, adding -ts_dt 0.1 should work.

      
    
  


Further information
Because this example uses DMDA, Jacobian can be efficiently approximated using finite difference with coloring. You can use the option -snes_fd_color to enable this feature.

Out-Brief

We have used PETSc to demonstrate the adjoint capability as an enabling technology for dynamic-constrained optimization. In particular, we investigated an inverse initial value porblem built on a time-dependent reaction-diffusion PDE.

We have shown the basic usage of the adjoint solver as well as functionalities that can facilitate rapid development, diagnosis and performance profiling.

Further Reading

PETSc Documentation



 



Back to all HandsOnLessons">
	
	

	<link type="text/plain" rel="author" href="http://localhost:4000/humans.txt">

	

	

	<link rel="icon" sizes="32x32" href="http://localhost:4000/assets/img/favicon-32x32.png">

	<link rel="icon" sizes="192x192" href="http://localhost:4000/assets/img/touch-icon-192x192.png">

	<link rel="apple-touch-icon-precomposed" sizes="180x180" href="http://localhost:4000/assets/img/apple-touch-icon-180x180-precomposed.png">

	<link rel="apple-touch-icon-precomposed" sizes="152x152" href="http://localhost:4000/assets/img/apple-touch-icon-152x152-precomposed.png">

	<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://localhost:4000/assets/img/apple-touch-icon-144x144-precomposed.png">

	<link rel="apple-touch-icon-precomposed" sizes="120x120" href="http://localhost:4000/assets/img/apple-touch-icon-120x120-precomposed.png">

	<link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://localhost:4000/assets/img/apple-touch-icon-114x114-precomposed.png">

	
	<link rel="apple-touch-icon-precomposed" sizes="76x76" href="http://localhost:4000/assets/img/apple-touch-icon-76x76-precomposed.png">

	<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/assets/img/apple-touch-icon-72x72-precomposed.png">

	<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/assets/img/apple-touch-icon-precomposed.png">	

	<meta name="msapplication-TileImage" content="http://localhost:4000/assets/img/msapplication_tileimage.png">

	<meta name="msapplication-TileColor" content="#fabb00">


	

        
	   <!-- MathJax Config
                    CommonHTML: {
                        scale: 200
                    }
            <script type="text/x-mathjax-config">
                MathJax.Hub.Config({
                    displayAlign: "left"
                });
            </script>
            -->
            <script type="text/javascript" async
                src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async>
            </script>
            <script type="text/x-mathjax-config">
                MathJax.Hub.Config({
                    TeX: { 
                        equationNumbers: {  autoNumber: "all"  }
                    }
                });
            </script>
        

</head>
<body id="top-of-page" class="page-fullwidth">
        

	
	
<div id="navigation" class="sticky">
  <nav class="top-bar" role="navigation" data-topbar>
    <ul class="title-area">
      <li class="name">
      <h1 class="show-for-small-only"><a href="http://localhost:4000" class="icon-tree"> ATPESC 2018 Math Library Hands On Exercises</a></h1>
    </li>
       <!-- Remove the class "menu-icon" to get rid of menu icon. Take out "Menu" to just have icon alone -->
      <li class="toggle-topbar menu-icon"><a href="#"><span>Nav</span></a></li>
    </ul>
    <section class="top-bar-section">

      <ul class="right">
        
              

              

          
          
        
              

              

          
          
        
              

              

          
          
        
              

              

          
          
        
        
      </ul>

      <ul class="left">
        
              

              

          
          

            
            

              <li class="has-dropdown">
                <a  href="http://localhost:4000/">Intro</a>

                  <ul class="dropdown">
                    

                      

                      <li><a  href="http://localhost:4000/about_your_day/">About Your Day</a></li>
                    

                      

                      <li><a  href="http://localhost:4000/setup_instructions/">Setup Instructions</a></li>
                    

                      

                      <li><a  href="http://localhost:4000/atpesc_2018_agenda/">Today&#39;s Agenda</a></li>
                    

                      

                      <li><a  href="https://www.alcf.anl.gov/user-guides" target="_blank">ALCF User Guides</a></li>
                    

                      

                      <li><a  href="https://hangouts.google.com/group/wuWDDdPe4mX1u0v83" target="_blank">Open Chat</a></li>
                    

                      

                      <li><a  href="http://localhost:4000/pages/one_on_one_schedule.html">One-on-One Schedule</a></li>
                    

                      

                      <li><a  href="https://goo.gl/forms/B7UFpBvEOJbC58oJ2" target="_blank">Submit a Show Your Work</a></li>
                    
                  </ul>

              </li>
              <li class="divider"></li>
            
          
        
              

              

          
          

            
            

              <li class="has-dropdown">
                <a  href="http://localhost:4000/lessons/">Lessons</a>

                  <ul class="dropdown">
                    

                      

                      <li><a  href="http://localhost:4000/lessons/hand_coded_heat/">Hand Coded Heat</a></li>
                    

                      

                      <li><a  href="http://localhost:4000/lessons/mfem_convergence/">Meshing and Discretization (MFEM)</a></li>
                    

                      

                      <li><a  href="http://localhost:4000/lessons/pumi/">MFEM+PUMI Adaptive Workflow</a></li>
                    

                      

                      <li><a  href="http://localhost:4000/lessons/time_integrators/">Time Integration &amp; Non-Linear Solvers</a></li>
                    

                      

                      <li><a  href="http://localhost:4000/lessons/krylov_amg/">Krylov Solvers and Algebraic Multigrid</a></li>
                    

                      

                      <li><a  href="http://localhost:4000/lessons/superlu_mfem/">Sparse Direct Solvers</a></li>
                    

                      

                      <li><a  href="http://localhost:4000/lessons/adjoint/">Numerical Optimization (Adjoint)</a></li>
                    

                      

                      <li><a  href="http://localhost:4000/lessons/obstacle_tao">Numerical Optimization</a></li>
                    
                  </ul>

              </li>
              <li class="divider"></li>
            
          
        
              

              

          
          

            
            

              <li class="has-dropdown">
                <a  href="https://fastmath-scidac.org/software-catalog.html" target="_blank">Packages</a>

                  <ul class="dropdown">
                    

                      

                      <li><a  href="http://mfem.org" target="_blank">MFEM</a></li>
                    

                      

                      <li><a  href="https://www.scorec.rpi.edu/pumi" target="_blank">PUMI</a></li>
                    

                      

                      <li><a  href="https://www.mcs.anl.gov/petsc/" target="_blank">PETSc</a></li>
                    

                      

                      <li><a  href="https://computation.llnl.gov/projects/hypre-scalable-linear-solvers-multigrid-methods" target="_blank">HYPRE</a></li>
                    

                      

                      <li><a  href="http://crd-legacy.lbl.gov/~xiaoye/SuperLU" target="_blank">SuperLU</a></li>
                    

                      

                      <li><a  href="http://www.mcs.anl.gov/research/projects/tao/tao-deprecated/index.html" target="_blank">Tao</a></li>
                    
                  </ul>

              </li>
              <li class="divider"></li>
            
          
        
              

              

          
          

            
            

              <li class="has-dropdown">
                <a  href="http://localhost:4000/contributing_guide/">Contributing</a>

                  <ul class="dropdown">
                    

                      

                      <li><a  href="http://localhost:4000/contributing_guide/">Contributing Guide</a></li>
                    

                      

                      <li><a  href="http://localhost:4000/info/">Why the new theme?</a></li>
                    

                      

                      <li><a  href="http://localhost:4000/headers/">Many Header Styles</a></li>
                    

                      

                      <li><a  href="http://localhost:4000/design/">Many Design Options</a></li>
                    

                      

                      <li><a  href="http://localhost:4000/documentation/">Full Documentation</a></li>
                    
                  </ul>

              </li>
              <li class="divider"></li>
            
          
        
        
      </ul>
    </section>
  </nav>
</div><!-- /#navigation -->

	

	

<div id="masthead">
	<div class="row">
		<div class="small-12 columns">
			<a id="logo" href="http://localhost:4000/" title="ATPESC 2018 Math Library Hands On Exercises – So my code will see the future">
				<img src="http://localhost:4000/assets/img/logo.png" alt="ATPESC 2018 Math Library Hands On Exercises – So my code will see the future">
			</a>
		</div><!-- /.small-12.columns -->
	</div><!-- /.row -->
</div><!-- /#masthead -->










	


<div class="row t30">
	<div class="medium-12 columns">
		<article>
			<header>
				<p class="subheadline">Adjoin time dependent differential equations</p>
				<h1>Using adjoint for PDE-constrained optimization</h1>
			</header>

			

			<h2 id="at-a-glance">At a Glance</h2>
<!-- (Expected # minutes to complete) %% temporarily omit -->

<table>
  <tbody>
    <tr>
      <td>Questions</td>
      <td>Objectives</td>
      <td>Key Points</td>
    </tr>
    <tr>
      <td>How can gradients be computed for simulations?</td>
      <td>Know PETSc/TAO’s capability for adjoint and optimization</td>
      <td>Adjoint enables dynamic constrained optimization</td>
    </tr>
    <tr>
      <td>How difficult is it to use the adjoint method?</td>
      <td>Understand ingredients needed  for adjoint calculation</td>
      <td>Jacobian is imperative</td>
    </tr>
    <tr>
      <td> </td>
      <td>Understand the concern of checkpointing</td>
      <td>Performance may depend on checkpointing at large scale</td>
    </tr>
  </tbody>
</table>

<p><strong>Note:</strong> To begin this lesson…</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd HandsOnLessons/adjoint
</code></pre></div></div>

<h2 id="an-inverse-initial-value-problem">An Inverse Initial Value Problem</h2>

<p>This code demonstrates how to solve an inverse initial value problem for a system of time-dependent PDEs on a 2D rectangular grid.
The goal is to determine an optimal initial condition that can minimizes the difference between the simulated result and the reference solution.
We will use this example to illustrate the performance considerations for realistic large-scale applications. In particular, we will show how to play with checkpointing and how to profile/tune the performance.</p>

<h3 id="compile-the-code">Compile the code</h3>
<p>The example <a href="https://bitbucket.org/petsc/petsc/src/master/src/ts/examples/tutorials/advection-diffusion-reaction/ex5opt_ic.c">ex5opt_ic.c</a> can be compiled with</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make ex5opt_ic
</code></pre></div></div>
<p>To clean the example, do</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make clean
</code></pre></div></div>

<p>ATPESC participants do not need to compile code because binaries are available in the ATPESC project folder on Cooley.</p>

<h3 id="command-line-options">Command line options</h3>
<p>You can determine the command line options available for this particular example by doing</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./ex5opt_ic -help
</code></pre></div></div>
<p>and show the options related to TAO only by doing</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./ex5opt_ic -help | grep tao
</code></pre></div></div>

<h3 id="problem-being-solved">Problem being solved</h3>

<p>The underlying PDE models reaction and diffusion of two chemical species that can produce a variety of patterns. It is widely used to describe pattern-formation phenomena in biological, chemical and physical systems. The concentrations of the two species are calculated according to the equation</p>

<script type="math/tex; mode=display">\frac{d\mathbf{u}}{dt} = D_1 \nabla^2 \mathbf{u} - \mathbf{u} \mathbf{v}^2 +
\gamma(1 -\mathbf{u}) \\
\frac{d\mathbf{v}}{dt} = D_2 \nabla^2 \mathbf{v} + \mathbf{u} \mathbf{v}^2 -
(\gamma + \kappa)\mathbf{v}</script>

<p>The spatial pattern for the time interval [0,200] seconds is shown in the following figure.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Figure 1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><img src="pde.gif" width="400" /></td>
    </tr>
  </tbody>
</table>

<p>Given the pattern (observation) at the final time of the simulation, we want to determine the initial pattern that can minimize the difference between the simulated result and the observation.</p>

<script type="math/tex; mode=display">\text{minimize}_{X_0} \| X - X^{ref}\|</script>

<h3 id="run-1-monitor-solution-graphically">Run 1: Monitor solution graphically</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mpiexec -n 4 ./ex5opt_ic -forwardonly -ts_type rk -ts_rk_type 3 -ts_max_steps 20 -ts_monitor -ts_monitor_draw_solution
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">-forwardonly</code> perform the forward simulation without doing optimization</li>
  <li><code class="highlighter-rouge">-ts_type rk -ts_rk_type 3</code> changes the time stepping algorithm to a 3rd-order Runge-Kutta method</li>
  <li><code class="highlighter-rouge">-ts_monitor_draw_solution</code> monitors the progress for the solution at each time step</li>
  <li>Add <code class="highlighter-rouge">-draw_pause -2</code> if you want to pause at the end of simulation to see the plot</li>
</ul>

<h3 id="run-2-optimal-checkpointing-schedule">Run 2: Optimal checkpointing schedule</h3>
<p>By default, the checkpoints are stored in binary files on disk. Of course, this may not be a good choice for large-scale applications running on high-performance machines where I/O cost is significant. We can make the solver use RAM for checkpointing and specify the maximum allowable checkpoints so that an optimal adjoint checkpointing schedule that minimizes the number of recomputations will be generated.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mpiexec -n 4 ./ex5opt_ic -ts_type rk -ts_rk_type 3 -ts_adapt_type none \
                     -ts_max_steps 10 -ts_monitor -ts_adjoint_monitor \
                     -ts_trajectory_type memory -ts_trajectory_max_cps_ram 3 \
                     -ts_trajectory_monitor -ts_trajectory_view -tao_max_it 1
</code></pre></div></div>
<ul>
  <li><code class="highlighter-rouge">-tao_max_it 1</code> forces the optimization to stop after one iteration so that we can focus on the output related to the adjoint checkpointing.
The output corresponds to the schedule depicted by the following diagram:</li>
</ul>

<p><img src="chkpt.png" width="800" /></p>

<h4 id="questions">Questions</h4>

<div class="qanda">
  
  <input id="qanda_toggle1" type="checkbox" unchecked="" />
  <label class="qanda" for="qanda_toggle1" style="font-size:150%">What will happen if we add the option <code class="highlighter-rouge">-ts_trajectory_max_cps_disk 2</code> to specify there are two available slots for disk checkpoints?
</label>
  <div id="qanda_expand1">
    <style>
      #qanda_toggle1:checked ~ #qanda_expand1 {
        
        
        
        
            height: 10vmin;
        
      }
    </style>
    <section>
      
          <p>Looking at the output, we will find that the new schedule uses both RAM and disk for checkpointing and takes two less recomputations.</p>

      
    </section>
  </div>
</div>

<h3 id="run-3-monitor-the-optimization-progress">Run 3: Monitor the optimization progress</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mpiexec -n 4 ./ex5opt_ic -ts_type rk -ts_rk_type 3 -ts_adapt_type none -ts_max_steps 5 -ts_trajectory_type memory -ts_trajectory_solution_only 0 -tao_monitor -tao_view
  0 TAO,  Function value: 8.48202,  Residual: 7.02449
  1 TAO,  Function value: 1.72589,  Residual: 2.46827
  2 TAO,  Function value: 0.556599,  Residual: 1.75419
  3 TAO,  Function value: 0.181113,  Residual: 0.698038
  4 TAO,  Function value: 0.0919628,  Residual: 0.390951
  5 TAO,  Function value: 0.0330733,  Residual: 0.276822
  6 TAO,  Function value: 0.0137442,  Residual: 0.205942
  7 TAO,  Function value: 0.0032463,  Residual: 0.0925536
  8 TAO,  Function value: 0.000876358,  Residual: 0.0469696
  9 TAO,  Function value: 0.000172022,  Residual: 0.0205954
 10 TAO,  Function value: 2.32065e-05,  Residual: 0.00808249
 11 TAO,  Function value: 1.00524e-05,  Residual: 0.00695292
 12 TAO,  Function value: 2.19094e-06,  Residual: 0.00192488
 13 TAO,  Function value: 9.37506e-07,  Residual: 0.00115926
 14 TAO,  Function value: 2.79883e-07,  Residual: 0.000907609
 15 TAO,  Function value: 7.22e-08,  Residual: 0.000346602
 16 TAO,  Function value: 3.51499e-08,  Residual: 0.000184429
 17 TAO,  Function value: 1.48741e-08,  Residual: 0.000117587
 18 TAO,  Function value: 7.83221e-09,  Residual: 9.19265e-05
 19 TAO,  Function value: 2.14226e-09,  Residual: 4.54118e-05
 20 TAO,  Function value: 8.99022e-10,  Residual: 2.91421e-05
 21 TAO,  Function value: 3.28239e-10,  Residual: 2.06652e-05
 22 TAO,  Function value: 1.85795e-10,  Residual: 2.71364e-05
 23 TAO,  Function value: 1.14498e-10,  Residual: 2.32933e-05
 24 TAO,  Function value: 8.12369e-11,  Residual: 2.22391e-05
 25 TAO,  Function value: 1.87747e-11,  Residual: 7.85018e-06
 26 TAO,  Function value: 7.29614e-12,  Residual: 5.02828e-06
 27 TAO,  Function value: 1.72522e-12,  Residual: 1.07136e-06
 28 TAO,  Function value: 1.0259e-12,  Residual: 7.63383e-07
 29 TAO,  Function value: 1.72785e-13,  Residual: 3.91911e-07
 30 TAO,  Function value: 1.0509e-13,  Residual: 2.75909e-07
 31 TAO,  Function value: 4.02491e-14,  Residual: 1.7222e-07
 32 TAO,  Function value: 1.5385e-14,  Residual: 1.21345e-07
 33 TAO,  Function value: 3.20145e-15,  Residual: 7.81137e-08
 34 TAO,  Function value: 1.66953e-15,  Residual: 5.25802e-08
 35 TAO,  Function value: 3.39432e-16,  Residual: 3.16327e-08
 36 TAO,  Function value: 9.68078e-17,  Residual: 1.15783e-08
 37 TAO,  Function value: 8.23443e-17,  Residual: 1.68247e-08
 38 TAO,  Function value: 1.53356e-17,  Residual: 7.63537e-09
Tao Object: 4 MPI processes
  type: blmvm
  Gradient steps: 0
  Mat Object: (tao_blmvm_) 4 MPI processes
    type: lmvmbfgs
    rows=8192, cols=8192
      Scale type: diagonal
      Scale history: 1
      Scale params: alpha=1., beta=0.5, rho=1.
      Convex factors: phi=0., theta=0.125
      Max. storage: 5
      Used storage: 5
      Number of updates: 37
      Number of rejects: 0
      Number of resets: 1
  TaoLineSearch Object: 4 MPI processes
    type: more-thuente
    maximum function evaluations=30
    tolerances: ftol=0.0001, rtol=1e-10, gtol=0.9
    total number of function evaluations=0
    total number of gradient evaluations=0
    total number of function/gradient evaluations=1
    using variable bounds
    Termination reason: 1
  Active Set subset type: subvec
  convergence tolerances: gatol=1e-08,   steptol=0.,   gttol=0.
  Residual in Function/Gradient:=7.63537e-09
  Objective value=1.53356e-17
  total number of iterations=38,                          (max: 2000)
  total number of function/gradient evaluations=41,      (max: 4000)
  Solution converged:    ||g(X)|| &lt;= gatol
</code></pre></div></div>
<ul>
  <li><code class="highlighter-rouge">-tao_draw_solution</code> can visualize the solution at each optimization iteration</li>
</ul>

<h4 id="questions-1">Questions</h4>

<div class="qanda">
  
  <input id="qanda_toggle2" type="checkbox" unchecked="" />
  <label class="qanda" for="qanda_toggle2" style="font-size:150%">Examine the source code and find the user-provided functions for TAO, TS, and TSAdjoint respectively.
</label>
  <div id="qanda_expand2">
    <style>
      #qanda_toggle2:checked ~ #qanda_expand2 {
        
        
        
        
            height: 14vmin;
        
      }
    </style>
    <section>
      
          <p>Essential functions we have provided are FormFunctionGradient for TAO, TSIFunction and TSIJacobian for TS,  RHSJacobianP for TSAdjoint. Because of the integral in the objective function, extra functions including CostIntegrand, DRDYFunction and DRDPFunction are given to TSAdjoint.</p>

      
    </section>
  </div>
</div>

<h3 id="run-4-implicit-time-integration-method">Run 4: Implicit time integration method</h3>
<p>Now we switch to an implicit method (<a href="https://en.wikipedia.org/wiki/Crank–Nicolson_method">Crank-Nicolson</a>) using fixed stepsize, which is the default setting in the code. At each time step, a nonlinear system is solved by the PETSc nonlinear solver <code class="highlighter-rouge">SNES</code>.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mpiexec -n 12 ./ex5opt_ic -ts_max_steps 5 -log_view -tao_monitor
</code></pre></div></div>
<ul>
  <li><code class="highlighter-rouge">-snes_monitor</code> can show the progress of <code class="highlighter-rouge">SNES</code></li>
  <li><code class="highlighter-rouge">-ts_monitor</code> can show the progress of <code class="highlighter-rouge">TS</code></li>
  <li><code class="highlighter-rouge">-log_view</code> prints a summary of the logging</li>
</ul>

<p>A snippet of the summary:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...
Phase summary info:
   Count: number of times phase was executed
   Time and Flop: Max - maximum over all processors
                   Ratio - ratio of maximum to minimum over all processors
   Mess: number of messages sent
   Avg. len: average message length (bytes)
   Reduct: number of global reductions
   Global: entire computation
   Stage: stages of a computation. Set stages with PetscLogStagePush() and PetscLogStagePop().
      %T - percent time in this phase         %F - percent flop in this phase
      %M - percent messages in this phase     %L - percent message lengths in this phase
      %R - percent reductions in this phase
   Total Mflop/s: 10e-6 * (sum of flop over all processors)/(max time over all processors)
------------------------------------------------------------------------------------------------------------------------
Event                Count      Time (sec)     Flop                             --- Global ---  --- Stage ---   Total
                   Max Ratio  Max     Ratio   Max  Ratio  Mess   Avg len Reduct  %T %F %M %L %R  %T %F %M %L %R Mflop/s
------------------------------------------------------------------------------------------------------------------------

--- Event Stage 0: Main Stage

VecDot              1130 1.0 3.9795e-01 1.4 1.59e+06 1.0 0.0e+00 0.0e+00 1.1e+03  4  1  0  0  8   4  1  0  0  8    46
VecMDot             1919 1.0 5.9272e-01 2.0 5.40e+06 1.0 0.0e+00 0.0e+00 1.9e+03  5  4  0  0 14   5  4  0  0 14   106
VecNorm             3678 1.0 8.1644e-01 1.3 5.18e+06 1.0 0.0e+00 0.0e+00 3.7e+03  9  4  0  0 27   9  4  0  0 27    74
...
</code></pre></div></div>

<h4 id="questions-2">Questions</h4>

<div class="qanda">
  
  <input id="qanda_toggle3" type="checkbox" unchecked="" />
  <label class="qanda" for="qanda_toggle3" style="font-size:150%">Where is the majority of CPU time spent?
</label>
  <div id="qanda_expand3">
    <style>
      #qanda_toggle3:checked ~ #qanda_expand3 {
        
        
        
        
            height: 16vmin;
        
      }
    </style>
    <section>
      
          <p>Of course answer may vary depending on the settings such as number of procs, problem size, and solver options. Typically most of the time should be spent on <a href="http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Vec/VecMDot.html">VecMDot</a> or <a href="http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Mat/MatMult.html">MatMult</a></p>

      
    </section>
  </div>
</div>

<div class="qanda">
  
  <input id="qanda_toggle4" type="checkbox" unchecked="" />
  <label class="qanda" for="qanda_toggle4" style="font-size:150%">How can we improve performance?
</label>
  <div id="qanda_expand4">
    <style>
      #qanda_toggle4:checked ~ #qanda_expand4 {
        
        
        
        
            height: 10vmin;
        
      }
    </style>
    <section>
      
          <ol>
  <li>Use memory instead of disk for checkpointing(<code class="highlighter-rouge">-ts_trajectory_type memory -ts_trajectory_solution_only 0</code>); 2. Tune the time stepping solver, nonlinear solver, linear solver, preconditioner and so forth.</li>
</ol>

      
    </section>
  </div>
</div>

<h3 id="run-5-scale-up-the-problem">Run 5: Scale up the problem</h3>
<p>We use explicit Runge-Kutta methods for time integration, and increase the grid resolution to 512 X 512.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mpiexec -n 12 ./ex5opt_ic -ts_type rk -ts_rk_type 3 -ts_adapt_type none -ts_max_steps 5 -ts_trajectory_type memory -ts_trajectory_solution_only 0 -tao_monitor -da_grid_x 512 -da_grid_y 512
</code></pre></div></div>

<h4 id="questions-3">Questions</h4>

<div class="qanda">
  
  <input id="qanda_toggle5" type="checkbox" unchecked="" />
  <label class="qanda" for="qanda_toggle5" style="font-size:150%">Does the optimization converge? If not, can you fix it?
</label>
  <div id="qanda_expand5">
    <style>
      #qanda_toggle5:checked ~ #qanda_expand5 {
        
        
        
        
            height: 10vmin;
        
      }
    </style>
    <section>
      
          <p>No. The PDE solution blows up. As we decrease the grid spacing, the stepsize  should be reduced according to CFL condition. For example, adding -ts_dt 0.1 should work.</p>

      
    </section>
  </div>
</div>

<h3 id="further-information">Further information</h3>
<p>Because this example uses <code class="highlighter-rouge">DMDA</code>, Jacobian can be efficiently approximated using finite difference with coloring. You can use the option <code class="highlighter-rouge">-snes_fd_color</code> to enable this feature.</p>

<h2 id="out-brief">Out-Brief</h2>

<p>We have used <a href="https://www.mcs.anl.gov/petsc/">PETSc</a> to demonstrate the adjoint capability as an enabling technology for dynamic-constrained optimization. In particular, we investigated an inverse initial value porblem built on a time-dependent reaction-diffusion PDE.</p>

<p>We have shown the basic usage of the adjoint solver as well as functionalities that can facilitate rapid development, diagnosis and performance profiling.</p>

<h2 id="further-reading">Further Reading</h2>

<p><a href="http://www.mcs.anl.gov/petsc/documentation/">PETSc Documentation</a></p>

<!-- Insert space, horizontal line, and link to HandsOnLesson table -->

<p> </p>

<hr />

<p><a href="../lessons.md">Back to all HandsOnLessons</a></p>


                        
                        <p><a href='../../lessons'>Back to all ATPESC 2018 Lessons</a></p>
                        

		</article>
	</div><!-- /.medium-12.columns -->
</div><!-- /.row -->




	
	    <div id="up-to-top" class="row">
      <div class="small-12 columns" style="text-align: right;">
        <a class="iconfont" href="#top-of-page">&#xf108;</a>
      </div><!-- /.small-12.columns -->
    </div><!-- /.row -->


    <footer id="footer-content" class="bg-grau">
      <div id="footer">
        <div class="row">
          <div class="medium-6 large-5 columns">
            <h5 class="shadow-black">About This Site</h5>

            <p class="shadow-black">
              <a href="https://software-carpentry.org">Software Carpentry</a> Style Lessons for Numerical Libraries
              <a href="http://localhost:4000/info/">More ›</a>
              Created by <a href="https://github.com/markcmiller86">Mark C Miller</a> with <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> based on <a href="http://phlow.github.io/feeling-responsive/">Feeling Responsive</a>.</p>
            </p>
          </div><!-- /.large-6.columns -->

          <div class="small-6 medium-3 large-3 columns">
            <ul class="inline-list social-icons">
            
              <li><a href="https://fastmath-scidac.llnl.gov" target="_blank" class="icon-home" title="FASTMath"></a></li>
            
              <li><a href="https://www.youtube.com/playlist?list=PLGj2a3KTwhRZKjI7pRFxQDBORsswJAdJt" target="_blank" class="icon-youtube" title="ATPESC-2017 Numerical Libaries"></a></li>
            
              <li><a href="https://www.youtube.com/channel/UCEkJLPAMOUsjC_RXGFcVq-A/videos" target="_blank" class="icon-youtube" title="IDEAS on YouTube"></a></li>
            
              <li><a href="http://twitter.com/exascaleproject" target="_blank" class="icon-twitter" title="Exascale Project on Twitter"></a></li>
            
            </ul>

                        <a class="button left r15 tiny radius" href="https://github.com/xsdk-project/ATPESC2018HandsOnLessons/edit/gh-pages/_lessons/adjoint/lesson.md">Edit This Page On GitHub</a>



          </div><!-- /.large-3.columns -->
        </div><!-- /.row -->

      </div><!-- /#footer -->

    </footer>

	

	


<script src="http://localhost:4000/assets/js/javascript.min.js"></script>



<script>
    $("#masthead").backstretch("http://localhost:4000/images/rd.jpg", {fade: 700});
    $("#masthead-with-text").backstretch("http://localhost:4000/images/rd.jpg", {fade: 700});
</script>












</body>
</html>

